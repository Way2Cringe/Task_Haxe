// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_feathers_controls_HDividedBox
#include <feathers/controls/HDividedBox.h>
#endif
#ifndef INCLUDED_feathers_controls_supportClasses_BaseDividedBox
#include <feathers/controls/supportClasses/BaseDividedBox.h>
#endif
#ifndef INCLUDED_feathers_core_FeathersControl
#include <feathers/core/FeathersControl.h>
#endif
#ifndef INCLUDED_feathers_core_IDisplayObject
#include <feathers/core/IDisplayObject.h>
#endif
#ifndef INCLUDED_feathers_core_IMeasureObject
#include <feathers/core/IMeasureObject.h>
#endif
#ifndef INCLUDED_feathers_core_IUIControl
#include <feathers/core/IUIControl.h>
#endif
#ifndef INCLUDED_feathers_core_IValidating
#include <feathers/core/IValidating.h>
#endif
#ifndef INCLUDED_feathers_core_InvalidationFlag
#include <feathers/core/InvalidationFlag.h>
#endif
#ifndef INCLUDED_feathers_core_MeasureSprite
#include <feathers/core/MeasureSprite.h>
#endif
#ifndef INCLUDED_feathers_core_ValidatingSprite
#include <feathers/core/ValidatingSprite.h>
#endif
#ifndef INCLUDED_feathers_layout_HDividedBoxLayout
#include <feathers/layout/HDividedBoxLayout.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayout
#include <feathers/layout/ILayout.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayoutObject
#include <feathers/layout/ILayoutObject.h>
#endif
#ifndef INCLUDED_feathers_style_IDarkModeTheme
#include <feathers/style/IDarkModeTheme.h>
#endif
#ifndef INCLUDED_feathers_style_IStyleObject
#include <feathers/style/IStyleObject.h>
#endif
#ifndef INCLUDED_feathers_style_ITheme
#include <feathers/style/ITheme.h>
#endif
#ifndef INCLUDED_feathers_style_IVariantStyleObject
#include <feathers/style/IVariantStyleObject.h>
#endif
#ifndef INCLUDED_feathers_themes_ClassVariantTheme
#include <feathers/themes/ClassVariantTheme.h>
#endif
#ifndef INCLUDED_feathers_themes_steel_BaseSteelTheme
#include <feathers/themes/steel/BaseSteelTheme.h>
#endif
#ifndef INCLUDED_feathers_themes_steel_components_SteelHDividedBoxStyles
#include <feathers/themes/steel/components/SteelHDividedBoxStyles.h>
#endif
#ifndef INCLUDED_feathers_utils_DisplayUtil
#include <feathers/utils/DisplayUtil.h>
#endif
#ifndef INCLUDED_lime_ui_MouseCursor
#include <lime/ui/MouseCursor.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_ui__MouseCursor_MouseCursor_Impl_
#include <openfl/ui/_MouseCursor/MouseCursor_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d64e1814d1fc946e_30_new,"feathers.controls.HDividedBox","new",0xc0604ca0,"feathers.controls.HDividedBox.new","feathers/controls/HDividedBox.hx",30,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_55_initializeHDividedBoxTheme,"feathers.controls.HDividedBox","initializeHDividedBoxTheme",0xc5f83791,"feathers.controls.HDividedBox.initializeHDividedBoxTheme","feathers/controls/HDividedBox.hx",55,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_59_addItemAt,"feathers.controls.HDividedBox","addItemAt",0xdd1d0a27,"feathers.controls.HDividedBox.addItemAt","feathers/controls/HDividedBox.hx",59,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_76_removeItem,"feathers.controls.HDividedBox","removeItem",0x18368b37,"feathers.controls.HDividedBox.removeItem","feathers/controls/HDividedBox.hx",76,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_89_initialize,"feathers.controls.HDividedBox","initialize",0x4212bd10,"feathers.controls.HDividedBox.initialize","feathers/controls/HDividedBox.hx",89,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_99_handleLayout,"feathers.controls.HDividedBox","handleLayout",0xaa06d032,"feathers.controls.HDividedBox.handleLayout","feathers/controls/HDividedBox.hx",99,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_107_prepareResize,"feathers.controls.HDividedBox","prepareResize",0x895c0b1b,"feathers.controls.HDividedBox.prepareResize","feathers/controls/HDividedBox.hx",107,0xe63ea6b0)
HX_LOCAL_STACK_FRAME(_hx_pos_d64e1814d1fc946e_126_commitResize,"feathers.controls.HDividedBox","commitResize",0x8b930d0b,"feathers.controls.HDividedBox.commitResize","feathers/controls/HDividedBox.hx",126,0xe63ea6b0)
namespace feathers{
namespace controls{

void HDividedBox_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_30_new)
HXLINE(  48)		this->_fallbackFluidIndex = -1;
HXLINE(  47)		this->_customItemWidths = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  37)		this->initializeHDividedBoxTheme();
HXLINE(  39)		super::__construct();
HXLINE(  42)		this->resizeCursor = ::openfl::ui::_MouseCursor::MouseCursor_Impl__obj::fromLimeCursor(::lime::ui::MouseCursor_obj::RESIZE_WE_dyn());
            	}

Dynamic HDividedBox_obj::__CreateEmpty() { return new HDividedBox_obj; }

void *HDividedBox_obj::_hx_vtable = 0;

Dynamic HDividedBox_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< HDividedBox_obj > _hx_result = new HDividedBox_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool HDividedBox_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x28751316) {
		if (inClassId<=(int)0x0c89e854) {
			if (inClassId<=(int)0x093ab78b) {
				if (inClassId<=(int)0x0330636f) {
					return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
				} else {
					return inClassId==(int)0x093ab78b;
				}
			} else {
				return inClassId==(int)0x0c89e854;
			}
		} else {
			return inClassId==(int)0x1f4df417 || inClassId==(int)0x28751316;
		}
	} else {
		if (inClassId<=(int)0x4af7dd8e) {
			if (inClassId<=(int)0x47eecb02) {
				return inClassId==(int)0x4033f4be || inClassId==(int)0x47eecb02;
			} else {
				return inClassId==(int)0x4af7dd8e;
			}
		} else {
			return inClassId==(int)0x58123034 || inClassId==(int)0x6b353933;
		}
	}
}

void HDividedBox_obj::initializeHDividedBoxTheme(){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_55_initializeHDividedBoxTheme)
HXDLIN(  55)		::feathers::themes::steel::components::SteelHDividedBoxStyles_obj::initialize(null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBox_obj,initializeHDividedBoxTheme,(void))

 ::openfl::display::DisplayObject HDividedBox_obj::addItemAt( ::openfl::display::DisplayObject child,int index){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_59_addItemAt)
HXLINE(  60)		 ::openfl::display::DisplayObject result = this->super::addItemAt(child,index);
HXLINE(  61)		 ::Dynamic explicitWidth = null();
HXLINE(  62)		if (::Std_obj::isOfType(child,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE(  63)			::Dynamic measureChild =  ::hx::interface_check(child,0xcfc32883);
HXLINE(  64)			explicitWidth = ::feathers::core::IMeasureObject_obj::get_explicitWidth(measureChild);
            		}
HXLINE(  66)		this->_customItemWidths->insert(index,explicitWidth);
HXLINE(  67)		int layoutIndex = this->_layoutItems->indexOf(child,null());
HXLINE(  68)		if (::hx::IsNull( explicitWidth )) {
HXLINE(  69)			bool _hx_tmp;
HXDLIN(  69)			if ((this->_fallbackFluidIndex != -1)) {
HXLINE(  69)				_hx_tmp = (layoutIndex > this->_fallbackFluidIndex);
            			}
            			else {
HXLINE(  69)				_hx_tmp = true;
            			}
HXDLIN(  69)			if (_hx_tmp) {
HXLINE(  70)				this->_fallbackFluidIndex = layoutIndex;
            			}
            		}
HXLINE(  73)		return result;
            	}


 ::openfl::display::DisplayObject HDividedBox_obj::removeItem( ::openfl::display::DisplayObject child){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_76_removeItem)
HXLINE(  77)		int index = this->items->indexOf(child,null());
HXLINE(  78)		int layoutIndex = this->_layoutItems->indexOf(child,null());
HXLINE(  79)		if ((this->_fallbackFluidIndex == layoutIndex)) {
HXLINE(  80)			this->_fallbackFluidIndex = -1;
            		}
HXLINE(  82)		 ::openfl::display::DisplayObject result = this->super::removeItem(child);
HXLINE(  83)		if ((index != -1)) {
HXLINE(  84)			this->_customItemWidths->removeRange(index,1);
            		}
HXLINE(  86)		return result;
            	}


void HDividedBox_obj::initialize(){
            	HX_GC_STACKFRAME(&_hx_pos_d64e1814d1fc946e_89_initialize)
HXLINE(  90)		this->super::initialize();
HXLINE(  92)		if (::hx::IsNull( this->_hDividedBoxLayout )) {
HXLINE(  93)			this->_hDividedBoxLayout =  ::feathers::layout::HDividedBoxLayout_obj::__alloc( HX_CTX );
            		}
HXLINE(  95)		this->_hDividedBoxLayout->set_customItemWidths(this->_customItemWidths);
HXLINE(  96)		this->layout = this->_hDividedBoxLayout;
            	}


void HDividedBox_obj::handleLayout(){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_99_handleLayout)
HXLINE( 100)		bool oldIgnoreChildChanges = this->_ignoreChildChanges;
HXLINE( 101)		this->_ignoreChildChanges = true;
HXLINE( 102)		this->_hDividedBoxLayout->set_fallbackFluidIndex(this->_fallbackFluidIndex);
HXLINE( 103)		this->_ignoreChildChanges = oldIgnoreChildChanges;
HXLINE( 104)		this->super::handleLayout();
            	}


void HDividedBox_obj::prepareResize(int dividerIndex,Float stageX,Float stageY){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_107_prepareResize)
HXLINE( 108)		this->_resizeStartStageX = stageX;
HXLINE( 110)		 ::openfl::display::DisplayObject firstItem = this->items->__get(dividerIndex).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 111)		 ::openfl::display::DisplayObject secondItem = this->items->__get((dividerIndex + 1)).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 112)		this->_resizeStartWidth1 = firstItem->get_width();
HXLINE( 113)		this->_resizeStartWidth2 = secondItem->get_width();
HXLINE( 115)		if (::hx::IsNotNull( this->_currentResizeDraggingSkin )) {
HXLINE( 116)			 ::openfl::display::InteractiveObject divider = this->dividers->__get(dividerIndex).StaticCast<  ::openfl::display::InteractiveObject >();
HXLINE( 117)			 ::openfl::display::DisplayObject _hx_tmp = this->_currentResizeDraggingSkin;
HXDLIN( 117)			_hx_tmp->set_y(divider->get_y());
HXLINE( 118)			 ::openfl::display::DisplayObject _hx_tmp1 = this->_currentResizeDraggingSkin;
HXDLIN( 118)			_hx_tmp1->set_height(divider->get_height());
HXLINE( 119)			if (::Std_obj::isOfType(this->_currentResizeDraggingSkin,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 120)				::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(this->_currentResizeDraggingSkin,0x64d4b3cd));
            			}
HXLINE( 122)			 ::openfl::display::DisplayObject _hx_tmp2 = this->_currentResizeDraggingSkin;
HXDLIN( 122)			Float _hx_tmp3 = divider->get_x();
HXDLIN( 122)			Float _hx_tmp4 = divider->get_width();
HXDLIN( 122)			_hx_tmp2->set_x((_hx_tmp3 + ((_hx_tmp4 - this->_currentResizeDraggingSkin->get_width()) / ((Float)2.0))));
            		}
            	}


void HDividedBox_obj::commitResize(int dividerIndex,Float stageX,Float stageY,bool live){
            	HX_STACKFRAME(&_hx_pos_d64e1814d1fc946e_126_commitResize)
HXLINE( 127)		Float offsetX = (stageX - this->_resizeStartStageX);
HXLINE( 128)		offsetX = (offsetX * ::feathers::utils::DisplayUtil_obj::getConcatenatedScaleX(::hx::ObjectPtr<OBJ_>(this)));
HXLINE( 130)		bool _hx_tmp;
HXDLIN( 130)		if (live) {
HXLINE( 130)			_hx_tmp = !(this->liveDragging);
            		}
            		else {
HXLINE( 130)			_hx_tmp = false;
            		}
HXDLIN( 130)		if (_hx_tmp) {
HXLINE( 131)			if (::hx::IsNotNull( this->_currentResizeDraggingSkin )) {
HXLINE( 132)				 ::openfl::display::InteractiveObject divider = this->dividers->__get(dividerIndex).StaticCast<  ::openfl::display::InteractiveObject >();
HXLINE( 133)				 ::openfl::display::DisplayObject _hx_tmp1 = this->_currentResizeDraggingSkin;
HXDLIN( 133)				_hx_tmp1->set_y(divider->get_y());
HXLINE( 134)				 ::openfl::display::DisplayObject _hx_tmp2 = this->_currentResizeDraggingSkin;
HXDLIN( 134)				_hx_tmp2->set_height(divider->get_height());
HXLINE( 135)				if (::Std_obj::isOfType(this->_currentResizeDraggingSkin,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 136)					::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(this->_currentResizeDraggingSkin,0x64d4b3cd));
            				}
HXLINE( 138)				 ::openfl::display::DisplayObject _hx_tmp3 = this->_currentResizeDraggingSkin;
HXDLIN( 138)				Float _hx_tmp4 = (divider->get_x() + offsetX);
HXDLIN( 138)				Float _hx_tmp5 = divider->get_width();
HXDLIN( 138)				_hx_tmp3->set_x((_hx_tmp4 + ((_hx_tmp5 - this->_currentResizeDraggingSkin->get_width()) / ((Float)2.0))));
            			}
HXLINE( 140)			return;
            		}
HXLINE( 143)		 ::openfl::display::DisplayObject firstItem = this->items->__get(dividerIndex).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 144)		 ::openfl::display::DisplayObject secondItem = this->items->__get((dividerIndex + 1)).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 146)		Float totalWidth = (this->_resizeStartWidth1 + this->_resizeStartWidth2);
HXLINE( 148)		Float secondItemWidth = (this->_resizeStartWidth2 - offsetX);
HXLINE( 149)		if (::Std_obj::isOfType(secondItem,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 150)			::Dynamic secondMeasureItem =  ::hx::interface_check(secondItem,0xcfc32883);
HXLINE( 151)			bool _hx_tmp6;
HXDLIN( 151)			if (::hx::IsNotNull( ::feathers::core::IMeasureObject_obj::get_explicitMinWidth(secondMeasureItem) )) {
HXLINE( 151)				_hx_tmp6 = ::hx::IsLess( secondItemWidth,::feathers::core::IMeasureObject_obj::get_explicitMinWidth(secondMeasureItem) );
            			}
            			else {
HXLINE( 151)				_hx_tmp6 = false;
            			}
HXDLIN( 151)			if (_hx_tmp6) {
HXLINE( 152)				secondItemWidth = ( (Float)(::feathers::core::IMeasureObject_obj::get_explicitMinWidth(secondMeasureItem)) );
            			}
            			else {
HXLINE( 153)				bool _hx_tmp7;
HXDLIN( 153)				if (::hx::IsNotNull( ::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(secondMeasureItem) )) {
HXLINE( 153)					_hx_tmp7 = ::hx::IsGreater( secondItemWidth,::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(secondMeasureItem) );
            				}
            				else {
HXLINE( 153)					_hx_tmp7 = false;
            				}
HXDLIN( 153)				if (_hx_tmp7) {
HXLINE( 154)					secondItemWidth = ( (Float)(::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(secondMeasureItem)) );
            				}
            			}
            		}
HXLINE( 157)		if ((secondItemWidth < ((Float)0.0))) {
HXLINE( 158)			secondItemWidth = ((Float)0.0);
            		}
            		else {
HXLINE( 159)			if ((secondItemWidth > totalWidth)) {
HXLINE( 160)				secondItemWidth = totalWidth;
            			}
            		}
HXLINE( 164)		Float firstItemWidth = (totalWidth - secondItemWidth);
HXLINE( 165)		if (::Std_obj::isOfType(firstItem,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 166)			::Dynamic firstMeasureItem =  ::hx::interface_check(firstItem,0xcfc32883);
HXLINE( 167)			bool _hx_tmp8;
HXDLIN( 167)			if (::hx::IsNotNull( ::feathers::core::IMeasureObject_obj::get_explicitMinWidth(firstMeasureItem) )) {
HXLINE( 167)				_hx_tmp8 = ::hx::IsLess( firstItemWidth,::feathers::core::IMeasureObject_obj::get_explicitMinWidth(firstMeasureItem) );
            			}
            			else {
HXLINE( 167)				_hx_tmp8 = false;
            			}
HXDLIN( 167)			if (_hx_tmp8) {
HXLINE( 168)				firstItemWidth = ( (Float)(::feathers::core::IMeasureObject_obj::get_explicitMinWidth(firstMeasureItem)) );
            			}
            			else {
HXLINE( 169)				bool _hx_tmp9;
HXDLIN( 169)				if (::hx::IsNotNull( ::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(firstMeasureItem) )) {
HXLINE( 169)					_hx_tmp9 = ::hx::IsGreater( firstItemWidth,::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(firstMeasureItem) );
            				}
            				else {
HXLINE( 169)					_hx_tmp9 = false;
            				}
HXDLIN( 169)				if (_hx_tmp9) {
HXLINE( 170)					firstItemWidth = ( (Float)(::feathers::core::IMeasureObject_obj::get_explicitMaxWidth(firstMeasureItem)) );
            				}
            			}
            		}
HXLINE( 173)		if ((firstItemWidth < ((Float)0.0))) {
HXLINE( 174)			firstItemWidth = ((Float)0.0);
            		}
            		else {
HXLINE( 175)			if ((firstItemWidth > totalWidth)) {
HXLINE( 176)				firstItemWidth = totalWidth;
            			}
            		}
HXLINE( 179)		secondItemWidth = (totalWidth - firstItemWidth);
HXLINE( 181)		this->_customItemWidths[dividerIndex] = firstItemWidth;
HXLINE( 182)		this->_customItemWidths[(dividerIndex + 1)] = secondItemWidth;
HXLINE( 183)		this->setInvalid(::feathers::core::InvalidationFlag_obj::LAYOUT_dyn());
            	}



::hx::ObjectPtr< HDividedBox_obj > HDividedBox_obj::__new() {
	::hx::ObjectPtr< HDividedBox_obj > __this = new HDividedBox_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< HDividedBox_obj > HDividedBox_obj::__alloc(::hx::Ctx *_hx_ctx) {
	HDividedBox_obj *__this = (HDividedBox_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(HDividedBox_obj), true, "feathers.controls.HDividedBox"));
	*(void **)__this = HDividedBox_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

HDividedBox_obj::HDividedBox_obj()
{
}

void HDividedBox_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(HDividedBox);
	HX_MARK_MEMBER_NAME(_hDividedBoxLayout,"_hDividedBoxLayout");
	HX_MARK_MEMBER_NAME(_customItemWidths,"_customItemWidths");
	HX_MARK_MEMBER_NAME(_fallbackFluidIndex,"_fallbackFluidIndex");
	HX_MARK_MEMBER_NAME(_resizeStartStageX,"_resizeStartStageX");
	HX_MARK_MEMBER_NAME(_resizeStartWidth1,"_resizeStartWidth1");
	HX_MARK_MEMBER_NAME(_resizeStartWidth2,"_resizeStartWidth2");
	 ::feathers::controls::supportClasses::BaseDividedBox_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void HDividedBox_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hDividedBoxLayout,"_hDividedBoxLayout");
	HX_VISIT_MEMBER_NAME(_customItemWidths,"_customItemWidths");
	HX_VISIT_MEMBER_NAME(_fallbackFluidIndex,"_fallbackFluidIndex");
	HX_VISIT_MEMBER_NAME(_resizeStartStageX,"_resizeStartStageX");
	HX_VISIT_MEMBER_NAME(_resizeStartWidth1,"_resizeStartWidth1");
	HX_VISIT_MEMBER_NAME(_resizeStartWidth2,"_resizeStartWidth2");
	 ::feathers::controls::supportClasses::BaseDividedBox_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val HDividedBox_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"addItemAt") ) { return ::hx::Val( addItemAt_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"removeItem") ) { return ::hx::Val( removeItem_dyn() ); }
		if (HX_FIELD_EQ(inName,"initialize") ) { return ::hx::Val( initialize_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"handleLayout") ) { return ::hx::Val( handleLayout_dyn() ); }
		if (HX_FIELD_EQ(inName,"commitResize") ) { return ::hx::Val( commitResize_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"prepareResize") ) { return ::hx::Val( prepareResize_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_customItemWidths") ) { return ::hx::Val( _customItemWidths ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_hDividedBoxLayout") ) { return ::hx::Val( _hDividedBoxLayout ); }
		if (HX_FIELD_EQ(inName,"_resizeStartStageX") ) { return ::hx::Val( _resizeStartStageX ); }
		if (HX_FIELD_EQ(inName,"_resizeStartWidth1") ) { return ::hx::Val( _resizeStartWidth1 ); }
		if (HX_FIELD_EQ(inName,"_resizeStartWidth2") ) { return ::hx::Val( _resizeStartWidth2 ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_fallbackFluidIndex") ) { return ::hx::Val( _fallbackFluidIndex ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"initializeHDividedBoxTheme") ) { return ::hx::Val( initializeHDividedBoxTheme_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val HDividedBox_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"_customItemWidths") ) { _customItemWidths=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_hDividedBoxLayout") ) { _hDividedBoxLayout=inValue.Cast<  ::feathers::layout::HDividedBoxLayout >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_resizeStartStageX") ) { _resizeStartStageX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_resizeStartWidth1") ) { _resizeStartWidth1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_resizeStartWidth2") ) { _resizeStartWidth2=inValue.Cast< Float >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_fallbackFluidIndex") ) { _fallbackFluidIndex=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void HDividedBox_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_hDividedBoxLayout",13,a0,11,40));
	outFields->push(HX_("_customItemWidths",90,ba,9f,57));
	outFields->push(HX_("_fallbackFluidIndex",89,c3,51,04));
	outFields->push(HX_("_resizeStartStageX",09,59,16,10));
	outFields->push(HX_("_resizeStartWidth1",9a,ec,20,56));
	outFields->push(HX_("_resizeStartWidth2",9b,ec,20,56));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo HDividedBox_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::feathers::layout::HDividedBoxLayout */ ,(int)offsetof(HDividedBox_obj,_hDividedBoxLayout),HX_("_hDividedBoxLayout",13,a0,11,40)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(HDividedBox_obj,_customItemWidths),HX_("_customItemWidths",90,ba,9f,57)},
	{::hx::fsInt,(int)offsetof(HDividedBox_obj,_fallbackFluidIndex),HX_("_fallbackFluidIndex",89,c3,51,04)},
	{::hx::fsFloat,(int)offsetof(HDividedBox_obj,_resizeStartStageX),HX_("_resizeStartStageX",09,59,16,10)},
	{::hx::fsFloat,(int)offsetof(HDividedBox_obj,_resizeStartWidth1),HX_("_resizeStartWidth1",9a,ec,20,56)},
	{::hx::fsFloat,(int)offsetof(HDividedBox_obj,_resizeStartWidth2),HX_("_resizeStartWidth2",9b,ec,20,56)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *HDividedBox_obj_sStaticStorageInfo = 0;
#endif

static ::String HDividedBox_obj_sMemberFields[] = {
	HX_("_hDividedBoxLayout",13,a0,11,40),
	HX_("_customItemWidths",90,ba,9f,57),
	HX_("_fallbackFluidIndex",89,c3,51,04),
	HX_("_resizeStartStageX",09,59,16,10),
	HX_("_resizeStartWidth1",9a,ec,20,56),
	HX_("_resizeStartWidth2",9b,ec,20,56),
	HX_("initializeHDividedBoxTheme",d1,2b,bd,78),
	HX_("addItemAt",e7,dd,2d,c1),
	HX_("removeItem",77,ff,de,c2),
	HX_("initialize",50,31,bb,ec),
	HX_("handleLayout",72,d4,e4,a6),
	HX_("prepareResize",db,be,c1,ce),
	HX_("commitResize",4b,11,71,88),
	::String(null()) };

::hx::Class HDividedBox_obj::__mClass;

void HDividedBox_obj::__register()
{
	HDividedBox_obj _hx_dummy;
	HDividedBox_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("feathers.controls.HDividedBox",ae,bc,5d,2a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(HDividedBox_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< HDividedBox_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HDividedBox_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HDividedBox_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace feathers
} // end namespace controls
