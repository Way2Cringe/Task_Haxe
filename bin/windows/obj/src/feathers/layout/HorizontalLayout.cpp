// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_feathers_core_IDisplayObject
#include <feathers/core/IDisplayObject.h>
#endif
#ifndef INCLUDED_feathers_core_IMeasureObject
#include <feathers/core/IMeasureObject.h>
#endif
#ifndef INCLUDED_feathers_core_IValidating
#include <feathers/core/IValidating.h>
#endif
#ifndef INCLUDED_feathers_events_FeathersEvent
#include <feathers/events/FeathersEvent.h>
#endif
#ifndef INCLUDED_feathers_layout_HorizontalAlign
#include <feathers/layout/HorizontalAlign.h>
#endif
#ifndef INCLUDED_feathers_layout_HorizontalLayout
#include <feathers/layout/HorizontalLayout.h>
#endif
#ifndef INCLUDED_feathers_layout_HorizontalLayoutData
#include <feathers/layout/HorizontalLayoutData.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayout
#include <feathers/layout/ILayout.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayoutData
#include <feathers/layout/ILayoutData.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayoutObject
#include <feathers/layout/ILayoutObject.h>
#endif
#ifndef INCLUDED_feathers_layout_LayoutBoundsResult
#include <feathers/layout/LayoutBoundsResult.h>
#endif
#ifndef INCLUDED_feathers_layout_Measurements
#include <feathers/layout/Measurements.h>
#endif
#ifndef INCLUDED_feathers_layout_VerticalAlign
#include <feathers/layout/VerticalAlign.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d038c4414a8a4fea_31_new,"feathers.layout.HorizontalLayout","new",0x67491286,"feathers.layout.HorizontalLayout.new","feathers/layout/HorizontalLayout.hx",31,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_61_get_paddingTop,"feathers.layout.HorizontalLayout","get_paddingTop",0x0fd3c927,"feathers.layout.HorizontalLayout.get_paddingTop","feathers/layout/HorizontalLayout.hx",61,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_64_set_paddingTop,"feathers.layout.HorizontalLayout","set_paddingTop",0x2ff3b19b,"feathers.layout.HorizontalLayout.set_paddingTop","feathers/layout/HorizontalLayout.hx",64,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_93_get_paddingRight,"feathers.layout.HorizontalLayout","get_paddingRight",0x586ab6ee,"feathers.layout.HorizontalLayout.get_paddingRight","feathers/layout/HorizontalLayout.hx",93,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_96_set_paddingRight,"feathers.layout.HorizontalLayout","set_paddingRight",0xaeaca462,"feathers.layout.HorizontalLayout.set_paddingRight","feathers/layout/HorizontalLayout.hx",96,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_125_get_paddingBottom,"feathers.layout.HorizontalLayout","get_paddingBottom",0x1c47eb99,"feathers.layout.HorizontalLayout.get_paddingBottom","feathers/layout/HorizontalLayout.hx",125,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_128_set_paddingBottom,"feathers.layout.HorizontalLayout","set_paddingBottom",0x3fb5c3a5,"feathers.layout.HorizontalLayout.set_paddingBottom","feathers/layout/HorizontalLayout.hx",128,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_157_get_paddingLeft,"feathers.layout.HorizontalLayout","get_paddingLeft",0xc42ae535,"feathers.layout.HorizontalLayout.get_paddingLeft","feathers/layout/HorizontalLayout.hx",157,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_160_set_paddingLeft,"feathers.layout.HorizontalLayout","set_paddingLeft",0xbff66241,"feathers.layout.HorizontalLayout.set_paddingLeft","feathers/layout/HorizontalLayout.hx",160,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_192_get_gap,"feathers.layout.HorizontalLayout","get_gap",0xffbb92d3,"feathers.layout.HorizontalLayout.get_gap","feathers/layout/HorizontalLayout.hx",192,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_195_set_gap,"feathers.layout.HorizontalLayout","set_gap",0xf2bd23df,"feathers.layout.HorizontalLayout.set_gap","feathers/layout/HorizontalLayout.hx",195,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_227_get_minGap,"feathers.layout.HorizontalLayout","get_minGap",0x54004907,"feathers.layout.HorizontalLayout.get_minGap","feathers/layout/HorizontalLayout.hx",227,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_230_set_minGap,"feathers.layout.HorizontalLayout","set_minGap",0x577de77b,"feathers.layout.HorizontalLayout.set_minGap","feathers/layout/HorizontalLayout.hx",230,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_268_get_horizontalAlign,"feathers.layout.HorizontalLayout","get_horizontalAlign",0x2cbccc7e,"feathers.layout.HorizontalLayout.get_horizontalAlign","feathers/layout/HorizontalLayout.hx",268,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_271_set_horizontalAlign,"feathers.layout.HorizontalLayout","set_horizontalAlign",0x6959bf8a,"feathers.layout.HorizontalLayout.set_horizontalAlign","feathers/layout/HorizontalLayout.hx",271,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_305_get_verticalAlign,"feathers.layout.HorizontalLayout","get_verticalAlign",0xb12aa26c,"feathers.layout.HorizontalLayout.get_verticalAlign","feathers/layout/HorizontalLayout.hx",305,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_308_set_verticalAlign,"feathers.layout.HorizontalLayout","set_verticalAlign",0xd4987a78,"feathers.layout.HorizontalLayout.set_verticalAlign","feathers/layout/HorizontalLayout.hx",308,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_332_get_justifyResetEnabled,"feathers.layout.HorizontalLayout","get_justifyResetEnabled",0x087a4d9f,"feathers.layout.HorizontalLayout.get_justifyResetEnabled","feathers/layout/HorizontalLayout.hx",332,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_335_set_justifyResetEnabled,"feathers.layout.HorizontalLayout","set_justifyResetEnabled",0x0adbb6ab,"feathers.layout.HorizontalLayout.set_justifyResetEnabled","feathers/layout/HorizontalLayout.hx",335,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_363_get_percentWidthResetEnabled,"feathers.layout.HorizontalLayout","get_percentWidthResetEnabled",0x458c9836,"feathers.layout.HorizontalLayout.get_percentWidthResetEnabled","feathers/layout/HorizontalLayout.hx",363,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_366_set_percentWidthResetEnabled,"feathers.layout.HorizontalLayout","set_percentWidthResetEnabled",0x48b6e3aa,"feathers.layout.HorizontalLayout.set_percentWidthResetEnabled","feathers/layout/HorizontalLayout.hx",366,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_394_get_percentHeightResetEnabled,"feathers.layout.HorizontalLayout","get_percentHeightResetEnabled",0xb7104c9b,"feathers.layout.HorizontalLayout.get_percentHeightResetEnabled","feathers/layout/HorizontalLayout.hx",394,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_397_set_percentHeightResetEnabled,"feathers.layout.HorizontalLayout","set_percentHeightResetEnabled",0x78e806a7,"feathers.layout.HorizontalLayout.set_percentHeightResetEnabled","feathers/layout/HorizontalLayout.hx",397,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_416_setPadding,"feathers.layout.HorizontalLayout","setPadding",0x33f06ce9,"feathers.layout.HorizontalLayout.setPadding","feathers/layout/HorizontalLayout.hx",416,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_426_layout,"feathers.layout.HorizontalLayout","layout",0xb216c844,"feathers.layout.HorizontalLayout.layout","feathers/layout/HorizontalLayout.hx",426,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_514_validateItems,"feathers.layout.HorizontalLayout","validateItems",0xf1ec1930,"feathers.layout.HorizontalLayout.validateItems","feathers/layout/HorizontalLayout.hx",514,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_575_applyVerticalAlign,"feathers.layout.HorizontalLayout","applyVerticalAlign",0x2286b4bb,"feathers.layout.HorizontalLayout.applyVerticalAlign","feathers/layout/HorizontalLayout.hx",575,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_599_applyHorizontalAlign,"feathers.layout.HorizontalLayout","applyHorizontalAlign",0xbafd508d,"feathers.layout.HorizontalLayout.applyHorizontalAlign","feathers/layout/HorizontalLayout.hx",599,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_642_applyPercentWidth,"feathers.layout.HorizontalLayout","applyPercentWidth",0x97110835,"feathers.layout.HorizontalLayout.applyPercentWidth","feathers/layout/HorizontalLayout.hx",642,0x9ce8818a)
HX_LOCAL_STACK_FRAME(_hx_pos_d038c4414a8a4fea_741_applyPercentHeight,"feathers.layout.HorizontalLayout","applyPercentHeight",0x4e259ed8,"feathers.layout.HorizontalLayout.applyPercentHeight","feathers/layout/HorizontalLayout.hx",741,0x9ce8818a)
namespace feathers{
namespace layout{

void HorizontalLayout_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_31_new)
HXLINE( 375)		this->_percentHeightResetEnabled = false;
HXLINE( 344)		this->_percentWidthResetEnabled = false;
HXLINE( 317)		this->_justifyResetEnabled = false;
HXLINE( 280)		this->_verticalAlign = ::feathers::layout::VerticalAlign_obj::TOP_dyn();
HXLINE( 239)		this->_horizontalAlign = ::feathers::layout::HorizontalAlign_obj::LEFT_dyn();
HXLINE( 204)		this->_minGap = ((Float)0.0);
HXLINE( 169)		this->_gap = ((Float)0.0);
HXLINE( 137)		this->_paddingLeft = ((Float)0.0);
HXLINE( 105)		this->_paddingBottom = ((Float)0.0);
HXLINE(  73)		this->_paddingRight = ((Float)0.0);
HXLINE(  41)		this->_paddingTop = ((Float)0.0);
HXLINE(  38)		super::__construct(null());
            	}

Dynamic HorizontalLayout_obj::__CreateEmpty() { return new HorizontalLayout_obj; }

void *HorizontalLayout_obj::_hx_vtable = 0;

Dynamic HorizontalLayout_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< HorizontalLayout_obj > _hx_result = new HorizontalLayout_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool HorizontalLayout_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0c89e854) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0c89e854;
	} else {
		return inClassId==(int)0x37a66054;
	}
}

static ::openfl::events::IEventDispatcher_obj _hx_feathers_layout_HorizontalLayout__hx_openfl_events_IEventDispatcher= {
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ,::hx::Null< int > ,::hx::Null< bool > ))&::feathers::layout::HorizontalLayout_obj::addEventListener,
	( bool (::hx::Object::*)( ::openfl::events::Event))&::feathers::layout::HorizontalLayout_obj::dispatchEvent,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HorizontalLayout_obj::hasEventListener,
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ))&::feathers::layout::HorizontalLayout_obj::removeEventListener,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HorizontalLayout_obj::willTrigger,
};

static ::feathers::layout::ILayout_obj _hx_feathers_layout_HorizontalLayout__hx_feathers_layout_ILayout= {
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ,::hx::Null< int > ,::hx::Null< bool > ))&::feathers::layout::HorizontalLayout_obj::addEventListener,
	( bool (::hx::Object::*)( ::openfl::events::Event))&::feathers::layout::HorizontalLayout_obj::dispatchEvent,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HorizontalLayout_obj::hasEventListener,
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ))&::feathers::layout::HorizontalLayout_obj::removeEventListener,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HorizontalLayout_obj::willTrigger,
	(  ::feathers::layout::LayoutBoundsResult (::hx::Object::*)(::Array< ::Dynamic>, ::feathers::layout::Measurements, ::feathers::layout::LayoutBoundsResult))&::feathers::layout::HorizontalLayout_obj::layout,
};

void *HorizontalLayout_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x87530281: return &_hx_feathers_layout_HorizontalLayout__hx_openfl_events_IEventDispatcher;
		case (int)0x3e135379: return &_hx_feathers_layout_HorizontalLayout__hx_feathers_layout_ILayout;
	}
	return super::_hx_getInterface(inHash);
}

Float HorizontalLayout_obj::get_paddingTop(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_61_get_paddingTop)
HXDLIN(  61)		return this->_paddingTop;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_paddingTop,return )

Float HorizontalLayout_obj::set_paddingTop(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_64_set_paddingTop)
HXLINE(  65)		if ((this->_paddingTop == value)) {
HXLINE(  66)			return this->_paddingTop;
            		}
HXLINE(  68)		this->_paddingTop = value;
HXLINE(  69)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE(  70)		return this->_paddingTop;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_paddingTop,return )

Float HorizontalLayout_obj::get_paddingRight(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_93_get_paddingRight)
HXDLIN(  93)		return this->_paddingRight;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_paddingRight,return )

Float HorizontalLayout_obj::set_paddingRight(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_96_set_paddingRight)
HXLINE(  97)		if ((this->_paddingRight == value)) {
HXLINE(  98)			return this->_paddingRight;
            		}
HXLINE( 100)		this->_paddingRight = value;
HXLINE( 101)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 102)		return this->_paddingRight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_paddingRight,return )

Float HorizontalLayout_obj::get_paddingBottom(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_125_get_paddingBottom)
HXDLIN( 125)		return this->_paddingBottom;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_paddingBottom,return )

Float HorizontalLayout_obj::set_paddingBottom(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_128_set_paddingBottom)
HXLINE( 129)		if ((this->_paddingBottom == value)) {
HXLINE( 130)			return this->_paddingBottom;
            		}
HXLINE( 132)		this->_paddingBottom = value;
HXLINE( 133)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 134)		return this->_paddingBottom;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_paddingBottom,return )

Float HorizontalLayout_obj::get_paddingLeft(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_157_get_paddingLeft)
HXDLIN( 157)		return this->_paddingLeft;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_paddingLeft,return )

Float HorizontalLayout_obj::set_paddingLeft(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_160_set_paddingLeft)
HXLINE( 161)		if ((this->_paddingLeft == value)) {
HXLINE( 162)			return this->_paddingLeft;
            		}
HXLINE( 164)		this->_paddingLeft = value;
HXLINE( 165)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 166)		return this->_paddingLeft;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_paddingLeft,return )

Float HorizontalLayout_obj::get_gap(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_192_get_gap)
HXDLIN( 192)		return this->_gap;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_gap,return )

Float HorizontalLayout_obj::set_gap(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_195_set_gap)
HXLINE( 196)		if ((this->_gap == value)) {
HXLINE( 197)			return this->_gap;
            		}
HXLINE( 199)		this->_gap = value;
HXLINE( 200)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 201)		return this->_gap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_gap,return )

Float HorizontalLayout_obj::get_minGap(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_227_get_minGap)
HXDLIN( 227)		return this->_minGap;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_minGap,return )

Float HorizontalLayout_obj::set_minGap(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_230_set_minGap)
HXLINE( 231)		if ((this->_minGap == value)) {
HXLINE( 232)			return this->_minGap;
            		}
HXLINE( 234)		this->_minGap = value;
HXLINE( 235)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 236)		return this->_minGap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_minGap,return )

 ::feathers::layout::HorizontalAlign HorizontalLayout_obj::get_horizontalAlign(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_268_get_horizontalAlign)
HXDLIN( 268)		return this->_horizontalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_horizontalAlign,return )

 ::feathers::layout::HorizontalAlign HorizontalLayout_obj::set_horizontalAlign( ::feathers::layout::HorizontalAlign value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_271_set_horizontalAlign)
HXLINE( 272)		if (::hx::IsPointerEq( this->_horizontalAlign,value )) {
HXLINE( 273)			return this->_horizontalAlign;
            		}
HXLINE( 275)		this->_horizontalAlign = value;
HXLINE( 276)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 277)		return this->_horizontalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_horizontalAlign,return )

 ::feathers::layout::VerticalAlign HorizontalLayout_obj::get_verticalAlign(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_305_get_verticalAlign)
HXDLIN( 305)		return this->_verticalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_verticalAlign,return )

 ::feathers::layout::VerticalAlign HorizontalLayout_obj::set_verticalAlign( ::feathers::layout::VerticalAlign value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_308_set_verticalAlign)
HXLINE( 309)		if (::hx::IsPointerEq( this->_verticalAlign,value )) {
HXLINE( 310)			return this->_verticalAlign;
            		}
HXLINE( 312)		this->_verticalAlign = value;
HXLINE( 313)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 314)		return this->_verticalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_verticalAlign,return )

bool HorizontalLayout_obj::get_justifyResetEnabled(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_332_get_justifyResetEnabled)
HXDLIN( 332)		return this->_justifyResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_justifyResetEnabled,return )

bool HorizontalLayout_obj::set_justifyResetEnabled(bool value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_335_set_justifyResetEnabled)
HXLINE( 336)		if ((this->_justifyResetEnabled == value)) {
HXLINE( 337)			return this->_justifyResetEnabled;
            		}
HXLINE( 339)		this->_justifyResetEnabled = value;
HXLINE( 340)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 341)		return this->_justifyResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_justifyResetEnabled,return )

bool HorizontalLayout_obj::get_percentWidthResetEnabled(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_363_get_percentWidthResetEnabled)
HXDLIN( 363)		return this->_percentWidthResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_percentWidthResetEnabled,return )

bool HorizontalLayout_obj::set_percentWidthResetEnabled(bool value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_366_set_percentWidthResetEnabled)
HXLINE( 367)		if ((this->_percentWidthResetEnabled == value)) {
HXLINE( 368)			return this->_percentWidthResetEnabled;
            		}
HXLINE( 370)		this->_percentWidthResetEnabled = value;
HXLINE( 371)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 372)		return this->_percentWidthResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_percentWidthResetEnabled,return )

bool HorizontalLayout_obj::get_percentHeightResetEnabled(){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_394_get_percentHeightResetEnabled)
HXDLIN( 394)		return this->_percentHeightResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HorizontalLayout_obj,get_percentHeightResetEnabled,return )

bool HorizontalLayout_obj::set_percentHeightResetEnabled(bool value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_397_set_percentHeightResetEnabled)
HXLINE( 398)		if ((this->_percentHeightResetEnabled == value)) {
HXLINE( 399)			return this->_percentHeightResetEnabled;
            		}
HXLINE( 401)		this->_percentHeightResetEnabled = value;
HXLINE( 402)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 403)		return this->_percentHeightResetEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,set_percentHeightResetEnabled,return )

void HorizontalLayout_obj::setPadding(Float value){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_416_setPadding)
HXLINE( 417)		this->set_paddingTop(value);
HXLINE( 418)		this->set_paddingRight(value);
HXLINE( 419)		this->set_paddingBottom(value);
HXLINE( 420)		this->set_paddingLeft(value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(HorizontalLayout_obj,setPadding,(void))

 ::feathers::layout::LayoutBoundsResult HorizontalLayout_obj::layout(::Array< ::Dynamic> items, ::feathers::layout::Measurements measurements, ::feathers::layout::LayoutBoundsResult result){
            	HX_GC_STACKFRAME(&_hx_pos_d038c4414a8a4fea_426_layout)
HXLINE( 427)		Float adjustedGap = this->_gap;
HXLINE( 428)		bool hasFlexGap = (this->_gap == ::hx::DivByZero(((Float)1.0)));
HXLINE( 429)		if (hasFlexGap) {
HXLINE( 430)			adjustedGap = this->_minGap;
            		}
HXLINE( 433)		{
HXLINE( 433)			bool isJustified = ::hx::IsPointerEq( this->_verticalAlign,::feathers::layout::VerticalAlign_obj::JUSTIFY_dyn() );
HXDLIN( 433)			 ::Dynamic explicitContentWidth = measurements->width;
HXDLIN( 433)			if (::hx::IsNotNull( explicitContentWidth )) {
HXLINE( 433)				explicitContentWidth = (explicitContentWidth - (this->_paddingLeft + this->_paddingRight));
            			}
HXDLIN( 433)			 ::Dynamic explicitContentHeight = measurements->height;
HXDLIN( 433)			if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 433)				explicitContentHeight = (explicitContentHeight - (this->_paddingTop + this->_paddingBottom));
            			}
HXDLIN( 433)			{
HXLINE( 433)				int _g = 0;
HXDLIN( 433)				while((_g < items->length)){
HXLINE( 433)					 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 433)					_g = (_g + 1);
HXDLIN( 433)					 ::Dynamic percentWidth = null();
HXDLIN( 433)					 ::Dynamic percentHeight = null();
HXDLIN( 433)					if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 433)						::Dynamic layoutItem =  ::hx::interface_check(item,0xf54ca718);
HXDLIN( 433)						if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutItem))) {
HXLINE( 433)							continue;
            						}
HXDLIN( 433)						 ::feathers::layout::HorizontalLayoutData layoutData = ( ( ::feathers::layout::HorizontalLayoutData)(::Std_obj::downcast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutItem),::hx::ClassOf< ::feathers::layout::HorizontalLayoutData >())) );
HXDLIN( 433)						if (::hx::IsNotNull( layoutData )) {
HXLINE( 433)							percentWidth = layoutData->get_percentWidth();
HXDLIN( 433)							percentHeight = layoutData->get_percentHeight();
            						}
            					}
HXDLIN( 433)					if (isJustified) {
HXLINE( 433)						if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 433)							item->set_height(( (Float)(explicitContentHeight) ));
            						}
            						else {
HXLINE( 433)							bool _hx_tmp;
HXDLIN( 433)							if (this->_justifyResetEnabled) {
HXLINE( 433)								_hx_tmp = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            							}
            							else {
HXLINE( 433)								_hx_tmp = false;
            							}
HXDLIN( 433)							if (_hx_tmp) {
HXLINE( 433)								::feathers::core::IMeasureObject_obj::resetHeight( ::hx::interface_check(item,0xcfc32883));
            							}
            						}
            					}
            					else {
HXLINE( 433)						if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 433)							if (::hx::IsNotNull( percentHeight )) {
HXLINE( 433)								if (::hx::IsLess( percentHeight,((Float)0.0) )) {
HXLINE( 433)									percentHeight = ((Float)0.0);
            								}
            								else {
HXLINE( 433)									if (::hx::IsGreater( percentHeight,((Float)100.0) )) {
HXLINE( 433)										percentHeight = ((Float)100.0);
            									}
            								}
HXDLIN( 433)								item->set_height((( (Float)(explicitContentHeight) ) * (( (Float)(percentHeight) ) / ((Float)100.0))));
            							}
            						}
            						else {
HXLINE( 433)							bool _hx_tmp1;
HXDLIN( 433)							bool _hx_tmp2;
HXDLIN( 433)							if (::hx::IsNotNull( percentHeight )) {
HXLINE( 433)								_hx_tmp2 = this->_percentHeightResetEnabled;
            							}
            							else {
HXLINE( 433)								_hx_tmp2 = false;
            							}
HXDLIN( 433)							if (_hx_tmp2) {
HXLINE( 433)								_hx_tmp1 = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            							}
            							else {
HXLINE( 433)								_hx_tmp1 = false;
            							}
HXDLIN( 433)							if (_hx_tmp1) {
HXLINE( 433)								::feathers::core::IMeasureObject_obj::resetHeight( ::hx::interface_check(item,0xcfc32883));
            							}
            						}
            					}
HXDLIN( 433)					bool _hx_tmp3;
HXDLIN( 433)					bool _hx_tmp4;
HXDLIN( 433)					bool _hx_tmp5;
HXDLIN( 433)					if (::hx::IsNotNull( percentWidth )) {
HXLINE( 433)						_hx_tmp5 = this->_percentWidthResetEnabled;
            					}
            					else {
HXLINE( 433)						_hx_tmp5 = false;
            					}
HXDLIN( 433)					if (_hx_tmp5) {
HXLINE( 433)						_hx_tmp4 = ::hx::IsNull( explicitContentWidth );
            					}
            					else {
HXLINE( 433)						_hx_tmp4 = false;
            					}
HXDLIN( 433)					if (_hx_tmp4) {
HXLINE( 433)						_hx_tmp3 = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            					}
            					else {
HXLINE( 433)						_hx_tmp3 = false;
            					}
HXDLIN( 433)					if (_hx_tmp3) {
HXLINE( 433)						::feathers::core::IMeasureObject_obj::resetWidth( ::hx::interface_check(item,0xcfc32883));
            					}
HXDLIN( 433)					if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 433)						::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            					}
HXDLIN( 433)					bool _hx_tmp6;
HXDLIN( 433)					bool _hx_tmp7;
HXDLIN( 433)					if (isJustified) {
HXLINE( 433)						_hx_tmp7 = ::hx::IsNull( explicitContentHeight );
            					}
            					else {
HXLINE( 433)						_hx_tmp7 = false;
            					}
HXDLIN( 433)					if (_hx_tmp7) {
HXLINE( 433)						_hx_tmp6 = ::hx::IsNotNull( measurements->maxHeight );
            					}
            					else {
HXLINE( 433)						_hx_tmp6 = false;
            					}
HXDLIN( 433)					if (_hx_tmp6) {
HXLINE( 433)						Float maxExplicitContentHeight = ((( (Float)(measurements->maxHeight) ) - this->_paddingTop) - this->_paddingBottom);
HXDLIN( 433)						if ((item->get_height() > maxExplicitContentHeight)) {
HXLINE( 433)							item->set_height(maxExplicitContentHeight);
HXDLIN( 433)							if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 433)								::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 434)		this->applyPercentWidth(items,measurements->width,measurements->minWidth,measurements->maxWidth,adjustedGap);
HXLINE( 436)		Float contentWidth = this->_paddingLeft;
HXLINE( 437)		Float contentHeight = ((Float)0.0);
HXLINE( 438)		{
HXLINE( 438)			int _g1 = 0;
HXDLIN( 438)			while((_g1 < items->length)){
HXLINE( 438)				 ::openfl::display::DisplayObject item1 = items->__get(_g1).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 438)				_g1 = (_g1 + 1);
HXLINE( 439)				 ::feathers::layout::HorizontalLayoutData layoutData1 = null();
HXLINE( 440)				::Dynamic layoutObject = null();
HXLINE( 441)				if (::Std_obj::isOfType(item1,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 442)					layoutObject =  ::hx::interface_check(item1,0xf54ca718);
HXLINE( 443)					if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutObject))) {
HXLINE( 444)						continue;
            					}
HXLINE( 446)					layoutData1 = ( ( ::feathers::layout::HorizontalLayoutData)(::Std_obj::downcast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutObject),::hx::ClassOf< ::feathers::layout::HorizontalLayoutData >())) );
            				}
HXLINE( 448)				if (::Std_obj::isOfType(item1,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 449)					::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item1,0x64d4b3cd));
            				}
HXLINE( 451)				bool _hx_tmp8;
HXDLIN( 451)				if (::hx::IsNotNull( layoutData1 )) {
HXLINE( 451)					_hx_tmp8 = ::hx::IsNotNull( layoutData1->get_marginLeft() );
            				}
            				else {
HXLINE( 451)					_hx_tmp8 = false;
            				}
HXDLIN( 451)				if (_hx_tmp8) {
HXLINE( 452)					contentWidth = (contentWidth + layoutData1->get_marginLeft());
            				}
HXLINE( 454)				if ((contentHeight < item1->get_height())) {
HXLINE( 455)					contentHeight = item1->get_height();
            				}
HXLINE( 457)				item1->set_x(contentWidth);
HXLINE( 458)				contentWidth = (contentWidth + (item1->get_width() + adjustedGap));
HXLINE( 459)				bool _hx_tmp9;
HXDLIN( 459)				if (::hx::IsNotNull( layoutData1 )) {
HXLINE( 459)					_hx_tmp9 = ::hx::IsNotNull( layoutData1->get_marginRight() );
            				}
            				else {
HXLINE( 459)					_hx_tmp9 = false;
            				}
HXDLIN( 459)				if (_hx_tmp9) {
HXLINE( 460)					contentWidth = (contentWidth + layoutData1->get_marginRight());
            				}
            			}
            		}
HXLINE( 463)		Float maxItemHeight = contentHeight;
HXLINE( 464)		contentWidth = (contentWidth + this->_paddingRight);
HXLINE( 465)		if ((items->length > 0)) {
HXLINE( 466)			contentWidth = (contentWidth - adjustedGap);
            		}
HXLINE( 468)		contentHeight = (contentHeight + (this->_paddingTop + this->_paddingBottom));
HXLINE( 470)		Float viewPortWidth = contentWidth;
HXLINE( 471)		if (::hx::IsNotNull( measurements->width )) {
HXLINE( 472)			viewPortWidth = ( (Float)(measurements->width) );
            		}
            		else {
HXLINE( 474)			bool _hx_tmp10;
HXDLIN( 474)			if (::hx::IsNotNull( measurements->minWidth )) {
HXLINE( 474)				_hx_tmp10 = ::hx::IsLess( viewPortWidth,measurements->minWidth );
            			}
            			else {
HXLINE( 474)				_hx_tmp10 = false;
            			}
HXDLIN( 474)			if (_hx_tmp10) {
HXLINE( 475)				viewPortWidth = ( (Float)(measurements->minWidth) );
            			}
            			else {
HXLINE( 476)				bool _hx_tmp11;
HXDLIN( 476)				if (::hx::IsNotNull( measurements->maxWidth )) {
HXLINE( 476)					_hx_tmp11 = ::hx::IsGreater( viewPortWidth,measurements->maxWidth );
            				}
            				else {
HXLINE( 476)					_hx_tmp11 = false;
            				}
HXDLIN( 476)				if (_hx_tmp11) {
HXLINE( 477)					viewPortWidth = ( (Float)(measurements->maxWidth) );
            				}
            			}
            		}
HXLINE( 480)		Float viewPortHeight = contentHeight;
HXLINE( 481)		if (::hx::IsNotNull( measurements->height )) {
HXLINE( 482)			viewPortHeight = ( (Float)(measurements->height) );
            		}
            		else {
HXLINE( 484)			bool _hx_tmp12;
HXDLIN( 484)			if (::hx::IsNotNull( measurements->minHeight )) {
HXLINE( 484)				_hx_tmp12 = ::hx::IsLess( viewPortHeight,measurements->minHeight );
            			}
            			else {
HXLINE( 484)				_hx_tmp12 = false;
            			}
HXDLIN( 484)			if (_hx_tmp12) {
HXLINE( 485)				viewPortHeight = ( (Float)(measurements->minHeight) );
            			}
            			else {
HXLINE( 486)				bool _hx_tmp13;
HXDLIN( 486)				if (::hx::IsNotNull( measurements->maxHeight )) {
HXLINE( 486)					_hx_tmp13 = ::hx::IsGreater( viewPortHeight,measurements->maxHeight );
            				}
            				else {
HXLINE( 486)					_hx_tmp13 = false;
            				}
HXDLIN( 486)				if (_hx_tmp13) {
HXLINE( 487)					viewPortHeight = ( (Float)(measurements->maxHeight) );
            				}
            			}
            		}
HXLINE( 491)		this->applyPercentHeight(items,viewPortHeight);
HXLINE( 492)		{
HXLINE( 492)			int _g2 = 0;
HXDLIN( 492)			while((_g2 < items->length)){
HXLINE( 492)				 ::openfl::display::DisplayObject item2 = items->__get(_g2).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 492)				_g2 = (_g2 + 1);
HXDLIN( 492)				::Dynamic layoutObject1 = null();
HXDLIN( 492)				if (::Std_obj::isOfType(item2,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 492)					layoutObject1 =  ::hx::interface_check(item2,0xf54ca718);
HXDLIN( 492)					if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutObject1))) {
HXLINE( 492)						continue;
            					}
            				}
HXDLIN( 492)				switch((int)(this->_verticalAlign->_hx_getIndex())){
            					case (int)0: {
HXLINE( 492)						item2->set_y(this->_paddingTop);
            					}
            					break;
            					case (int)1: {
HXLINE( 492)						Float _hx_tmp14 = this->_paddingTop;
HXDLIN( 492)						Float _hx_tmp15 = this->_paddingTop;
HXDLIN( 492)						Float _hx_tmp16 = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXDLIN( 492)						item2->set_y(::Math_obj::max(_hx_tmp14,(_hx_tmp15 + ((_hx_tmp16 - item2->get_height()) / ((Float)2.0)))));
            					}
            					break;
            					case (int)2: {
HXLINE( 492)						Float _hx_tmp17 = this->_paddingTop;
HXDLIN( 492)						Float _hx_tmp18 = (this->_paddingTop + ((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
HXDLIN( 492)						item2->set_y(::Math_obj::max(_hx_tmp17,(_hx_tmp18 - item2->get_height())));
            					}
            					break;
            					case (int)3: {
HXLINE( 492)						item2->set_y(this->_paddingTop);
HXDLIN( 492)						item2->set_height(((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
            					}
            					break;
            				}
            			}
            		}
HXLINE( 493)		{
HXLINE( 493)			Float contentWidth1 = ((contentWidth - this->_paddingLeft) - this->_paddingRight);
HXDLIN( 493)			Float alignOffset = ((Float)0.0);
HXDLIN( 493)			Float gapOffset = ((Float)0.0);
HXDLIN( 493)			Float maxAlignmentWidth = ((viewPortWidth - this->_paddingLeft) - this->_paddingRight);
HXDLIN( 493)			Float adjustedGap1 = this->_gap;
HXDLIN( 493)			bool hasFlexGap1 = (this->_gap == ::hx::DivByZero(((Float)1.0)));
HXDLIN( 493)			if (hasFlexGap1) {
HXLINE( 493)				adjustedGap1 = this->_minGap;
HXDLIN( 493)				bool _hx_tmp19;
HXDLIN( 493)				if ((items->length > 1)) {
HXLINE( 493)					_hx_tmp19 = (maxAlignmentWidth > contentWidth1);
            				}
            				else {
HXLINE( 493)					_hx_tmp19 = false;
            				}
HXDLIN( 493)				if (_hx_tmp19) {
HXLINE( 493)					adjustedGap1 = (adjustedGap1 + ((maxAlignmentWidth - contentWidth1) / ( (Float)((items->length - 1)) )));
            				}
HXDLIN( 493)				gapOffset = (adjustedGap1 - this->_minGap);
            			}
            			else {
HXLINE( 493)				switch((int)(this->_horizontalAlign->_hx_getIndex())){
            					case (int)0: {
HXLINE( 493)						alignOffset = ((Float)0.0);
            					}
            					break;
            					case (int)1: {
HXLINE( 493)						alignOffset = ((maxAlignmentWidth - contentWidth1) / ((Float)2.0));
            					}
            					break;
            					case (int)2: {
HXLINE( 493)						alignOffset = (maxAlignmentWidth - contentWidth1);
            					}
            					break;
            					default:{
HXLINE( 493)						HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Unknown horizontal align: ",65,90,55,27) + ::Std_obj::string(this->_horizontalAlign))));
            					}
            				}
HXDLIN( 493)				if ((alignOffset < ((Float)0.0))) {
HXLINE( 493)					alignOffset = ((Float)0.0);
            				}
            			}
HXDLIN( 493)			bool _hx_tmp20;
HXDLIN( 493)			if ((alignOffset == ((Float)0.0))) {
HXLINE( 493)				_hx_tmp20 = (gapOffset == ((Float)0.0));
            			}
            			else {
HXLINE( 493)				_hx_tmp20 = false;
            			}
HXDLIN( 493)			if (!(_hx_tmp20)) {
HXLINE( 493)				Float totalOffset = alignOffset;
HXDLIN( 493)				{
HXLINE( 493)					int _g3 = 0;
HXDLIN( 493)					while((_g3 < items->length)){
HXLINE( 493)						 ::openfl::display::DisplayObject item3 = items->__get(_g3).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 493)						_g3 = (_g3 + 1);
HXDLIN( 493)						::Dynamic layoutObject2 = null();
HXDLIN( 493)						if (::Std_obj::isOfType(item3,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 493)							layoutObject2 =  ::hx::interface_check(item3,0xf54ca718);
HXDLIN( 493)							if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutObject2))) {
HXLINE( 493)								continue;
            							}
            						}
HXDLIN( 493)						Float _hx_tmp21 = this->_paddingLeft;
HXDLIN( 493)						item3->set_x(::Math_obj::max(_hx_tmp21,(item3->get_x() + totalOffset)));
HXDLIN( 493)						totalOffset = (totalOffset + gapOffset);
            					}
            				}
            			}
            		}
HXLINE( 495)		if ((contentWidth < viewPortWidth)) {
HXLINE( 496)			contentWidth = viewPortWidth;
            		}
HXLINE( 498)		if ((contentHeight < viewPortHeight)) {
HXLINE( 499)			contentHeight = viewPortHeight;
            		}
HXLINE( 502)		if (::hx::IsNull( result )) {
HXLINE( 503)			result =  ::feathers::layout::LayoutBoundsResult_obj::__alloc( HX_CTX );
            		}
HXLINE( 505)		result->contentX = ((Float)0.0);
HXLINE( 506)		result->contentY = ((Float)0.0);
HXLINE( 507)		result->contentWidth = contentWidth;
HXLINE( 508)		result->contentHeight = contentHeight;
HXLINE( 509)		result->viewPortWidth = viewPortWidth;
HXLINE( 510)		result->viewPortHeight = viewPortHeight;
HXLINE( 511)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC3(HorizontalLayout_obj,layout,return )

void HorizontalLayout_obj::validateItems(::Array< ::Dynamic> items, ::feathers::layout::Measurements measurements){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_514_validateItems)
HXLINE( 515)		bool isJustified = ::hx::IsPointerEq( this->_verticalAlign,::feathers::layout::VerticalAlign_obj::JUSTIFY_dyn() );
HXLINE( 516)		 ::Dynamic explicitContentWidth = measurements->width;
HXLINE( 517)		if (::hx::IsNotNull( explicitContentWidth )) {
HXLINE( 518)			explicitContentWidth = (explicitContentWidth - (this->_paddingLeft + this->_paddingRight));
            		}
HXLINE( 520)		 ::Dynamic explicitContentHeight = measurements->height;
HXLINE( 521)		if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 522)			explicitContentHeight = (explicitContentHeight - (this->_paddingTop + this->_paddingBottom));
            		}
HXLINE( 524)		{
HXLINE( 524)			int _g = 0;
HXDLIN( 524)			while((_g < items->length)){
HXLINE( 524)				 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 524)				_g = (_g + 1);
HXLINE( 525)				 ::Dynamic percentWidth = null();
HXLINE( 526)				 ::Dynamic percentHeight = null();
HXLINE( 527)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 528)					::Dynamic layoutItem =  ::hx::interface_check(item,0xf54ca718);
HXLINE( 529)					if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutItem))) {
HXLINE( 530)						continue;
            					}
HXLINE( 532)					 ::feathers::layout::HorizontalLayoutData layoutData = ( ( ::feathers::layout::HorizontalLayoutData)(::Std_obj::downcast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutItem),::hx::ClassOf< ::feathers::layout::HorizontalLayoutData >())) );
HXLINE( 533)					if (::hx::IsNotNull( layoutData )) {
HXLINE( 534)						percentWidth = layoutData->get_percentWidth();
HXLINE( 535)						percentHeight = layoutData->get_percentHeight();
            					}
            				}
HXLINE( 538)				if (isJustified) {
HXLINE( 539)					if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 540)						item->set_height(( (Float)(explicitContentHeight) ));
            					}
            					else {
HXLINE( 541)						bool _hx_tmp;
HXDLIN( 541)						if (this->_justifyResetEnabled) {
HXLINE( 541)							_hx_tmp = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            						}
            						else {
HXLINE( 541)							_hx_tmp = false;
            						}
HXDLIN( 541)						if (_hx_tmp) {
HXLINE( 542)							::feathers::core::IMeasureObject_obj::resetHeight( ::hx::interface_check(item,0xcfc32883));
            						}
            					}
            				}
            				else {
HXLINE( 544)					if (::hx::IsNotNull( explicitContentHeight )) {
HXLINE( 545)						if (::hx::IsNotNull( percentHeight )) {
HXLINE( 546)							if (::hx::IsLess( percentHeight,((Float)0.0) )) {
HXLINE( 547)								percentHeight = ((Float)0.0);
            							}
            							else {
HXLINE( 548)								if (::hx::IsGreater( percentHeight,((Float)100.0) )) {
HXLINE( 549)									percentHeight = ((Float)100.0);
            								}
            							}
HXLINE( 551)							item->set_height((( (Float)(explicitContentHeight) ) * (( (Float)(percentHeight) ) / ((Float)100.0))));
            						}
            					}
            					else {
HXLINE( 553)						bool _hx_tmp1;
HXDLIN( 553)						bool _hx_tmp2;
HXDLIN( 553)						if (::hx::IsNotNull( percentHeight )) {
HXLINE( 553)							_hx_tmp2 = this->_percentHeightResetEnabled;
            						}
            						else {
HXLINE( 553)							_hx_tmp2 = false;
            						}
HXDLIN( 553)						if (_hx_tmp2) {
HXLINE( 553)							_hx_tmp1 = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            						}
            						else {
HXLINE( 553)							_hx_tmp1 = false;
            						}
HXDLIN( 553)						if (_hx_tmp1) {
HXLINE( 554)							::feathers::core::IMeasureObject_obj::resetHeight( ::hx::interface_check(item,0xcfc32883));
            						}
            					}
            				}
HXLINE( 556)				bool _hx_tmp3;
HXDLIN( 556)				bool _hx_tmp4;
HXDLIN( 556)				bool _hx_tmp5;
HXDLIN( 556)				if (::hx::IsNotNull( percentWidth )) {
HXLINE( 556)					_hx_tmp5 = this->_percentWidthResetEnabled;
            				}
            				else {
HXLINE( 556)					_hx_tmp5 = false;
            				}
HXDLIN( 556)				if (_hx_tmp5) {
HXLINE( 556)					_hx_tmp4 = ::hx::IsNull( explicitContentWidth );
            				}
            				else {
HXLINE( 556)					_hx_tmp4 = false;
            				}
HXDLIN( 556)				if (_hx_tmp4) {
HXLINE( 556)					_hx_tmp3 = ::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >());
            				}
            				else {
HXLINE( 556)					_hx_tmp3 = false;
            				}
HXDLIN( 556)				if (_hx_tmp3) {
HXLINE( 557)					::feathers::core::IMeasureObject_obj::resetWidth( ::hx::interface_check(item,0xcfc32883));
            				}
HXLINE( 559)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 560)					::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            				}
HXLINE( 562)				bool _hx_tmp6;
HXDLIN( 562)				bool _hx_tmp7;
HXDLIN( 562)				if (isJustified) {
HXLINE( 562)					_hx_tmp7 = ::hx::IsNull( explicitContentHeight );
            				}
            				else {
HXLINE( 562)					_hx_tmp7 = false;
            				}
HXDLIN( 562)				if (_hx_tmp7) {
HXLINE( 562)					_hx_tmp6 = ::hx::IsNotNull( measurements->maxHeight );
            				}
            				else {
HXLINE( 562)					_hx_tmp6 = false;
            				}
HXDLIN( 562)				if (_hx_tmp6) {
HXLINE( 563)					Float maxExplicitContentHeight = ((( (Float)(measurements->maxHeight) ) - this->_paddingTop) - this->_paddingBottom);
HXLINE( 564)					if ((item->get_height() > maxExplicitContentHeight)) {
HXLINE( 565)						item->set_height(maxExplicitContentHeight);
HXLINE( 566)						if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 567)							::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(HorizontalLayout_obj,validateItems,(void))

void HorizontalLayout_obj::applyVerticalAlign(::Array< ::Dynamic> items,Float maxItemHeight,Float viewPortHeight){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_575_applyVerticalAlign)
HXDLIN( 575)		int _g = 0;
HXDLIN( 575)		while((_g < items->length)){
HXDLIN( 575)			 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 575)			_g = (_g + 1);
HXLINE( 576)			::Dynamic layoutObject = null();
HXLINE( 577)			if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 578)				layoutObject =  ::hx::interface_check(item,0xf54ca718);
HXLINE( 579)				if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutObject))) {
HXLINE( 580)					continue;
            				}
            			}
HXLINE( 583)			switch((int)(this->_verticalAlign->_hx_getIndex())){
            				case (int)0: {
HXLINE( 589)					item->set_y(this->_paddingTop);
            				}
            				break;
            				case (int)1: {
HXLINE( 587)					Float _hx_tmp = this->_paddingTop;
HXDLIN( 587)					Float _hx_tmp1 = this->_paddingTop;
HXDLIN( 587)					Float _hx_tmp2 = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXDLIN( 587)					item->set_y(::Math_obj::max(_hx_tmp,(_hx_tmp1 + ((_hx_tmp2 - item->get_height()) / ((Float)2.0)))));
            				}
            				break;
            				case (int)2: {
HXLINE( 585)					Float _hx_tmp3 = this->_paddingTop;
HXDLIN( 585)					Float _hx_tmp4 = (this->_paddingTop + ((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
HXDLIN( 585)					item->set_y(::Math_obj::max(_hx_tmp3,(_hx_tmp4 - item->get_height())));
            				}
            				break;
            				case (int)3: {
HXLINE( 591)					item->set_y(this->_paddingTop);
HXLINE( 592)					item->set_height(((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
            				}
            				break;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(HorizontalLayout_obj,applyVerticalAlign,(void))

void HorizontalLayout_obj::applyHorizontalAlign(::Array< ::Dynamic> items,Float contentWidth,Float viewPortWidth){
            	HX_GC_STACKFRAME(&_hx_pos_d038c4414a8a4fea_599_applyHorizontalAlign)
HXLINE( 600)		Float alignOffset = ((Float)0.0);
HXLINE( 601)		Float gapOffset = ((Float)0.0);
HXLINE( 602)		Float maxAlignmentWidth = ((viewPortWidth - this->_paddingLeft) - this->_paddingRight);
HXLINE( 603)		Float adjustedGap = this->_gap;
HXLINE( 604)		bool hasFlexGap = (this->_gap == ::hx::DivByZero(((Float)1.0)));
HXLINE( 605)		if (hasFlexGap) {
HXLINE( 606)			adjustedGap = this->_minGap;
HXLINE( 607)			bool _hx_tmp;
HXDLIN( 607)			if ((items->length > 1)) {
HXLINE( 607)				_hx_tmp = (maxAlignmentWidth > contentWidth);
            			}
            			else {
HXLINE( 607)				_hx_tmp = false;
            			}
HXDLIN( 607)			if (_hx_tmp) {
HXLINE( 608)				adjustedGap = (adjustedGap + ((maxAlignmentWidth - contentWidth) / ( (Float)((items->length - 1)) )));
            			}
HXLINE( 610)			gapOffset = (adjustedGap - this->_minGap);
            		}
            		else {
HXLINE( 612)			switch((int)(this->_horizontalAlign->_hx_getIndex())){
            				case (int)0: {
HXLINE( 613)					alignOffset = ((Float)0.0);
            				}
            				break;
            				case (int)1: {
HXLINE( 615)					alignOffset = ((maxAlignmentWidth - contentWidth) / ((Float)2.0));
            				}
            				break;
            				case (int)2: {
HXLINE( 614)					alignOffset = (maxAlignmentWidth - contentWidth);
            				}
            				break;
            				default:{
HXLINE( 617)					HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Unknown horizontal align: ",65,90,55,27) + ::Std_obj::string(this->_horizontalAlign))));
            				}
            			}
HXLINE( 619)			if ((alignOffset < ((Float)0.0))) {
HXLINE( 620)				alignOffset = ((Float)0.0);
            			}
            		}
HXLINE( 623)		bool _hx_tmp1;
HXDLIN( 623)		if ((alignOffset == ((Float)0.0))) {
HXLINE( 623)			_hx_tmp1 = (gapOffset == ((Float)0.0));
            		}
            		else {
HXLINE( 623)			_hx_tmp1 = false;
            		}
HXDLIN( 623)		if (_hx_tmp1) {
HXLINE( 624)			return;
            		}
HXLINE( 627)		Float totalOffset = alignOffset;
HXLINE( 628)		{
HXLINE( 628)			int _g = 0;
HXDLIN( 628)			while((_g < items->length)){
HXLINE( 628)				 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 628)				_g = (_g + 1);
HXLINE( 629)				::Dynamic layoutObject = null();
HXLINE( 630)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 631)					layoutObject =  ::hx::interface_check(item,0xf54ca718);
HXLINE( 632)					if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutObject))) {
HXLINE( 633)						continue;
            					}
            				}
HXLINE( 636)				Float _hx_tmp2 = this->_paddingLeft;
HXDLIN( 636)				item->set_x(::Math_obj::max(_hx_tmp2,(item->get_x() + totalOffset)));
HXLINE( 637)				totalOffset = (totalOffset + gapOffset);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(HorizontalLayout_obj,applyHorizontalAlign,(void))

void HorizontalLayout_obj::applyPercentWidth(::Array< ::Dynamic> items, ::Dynamic explicitWidth, ::Dynamic explicitMinWidth, ::Dynamic explicitMaxWidth,Float adjustedGap){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_642_applyPercentWidth)
HXLINE( 643)		::Array< ::Dynamic> pendingItems = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 644)		Float totalMeasuredWidth = ((Float)0.0);
HXLINE( 645)		Float totalMinWidth = ((Float)0.0);
HXLINE( 646)		Float totalPercentWidth = ((Float)0.0);
HXLINE( 647)		{
HXLINE( 647)			int _g = 0;
HXDLIN( 647)			while((_g < items->length)){
HXLINE( 647)				 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 647)				_g = (_g + 1);
HXLINE( 648)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >())) {
HXLINE( 649)					::Dynamic layoutItem =  ::hx::interface_check(item,0xf54ca718);
HXLINE( 650)					if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutItem))) {
HXLINE( 651)						continue;
            					}
HXLINE( 653)					 ::feathers::layout::HorizontalLayoutData layoutData = ( ( ::feathers::layout::HorizontalLayoutData)(::Std_obj::downcast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutItem),::hx::ClassOf< ::feathers::layout::HorizontalLayoutData >())) );
HXLINE( 654)					if (::hx::IsNotNull( layoutData )) {
HXLINE( 655)						 ::Dynamic percentWidth = layoutData->get_percentWidth();
HXLINE( 656)						if (::hx::IsNotNull( percentWidth )) {
HXLINE( 657)							if (::hx::IsLess( percentWidth,((Float)0.0) )) {
HXLINE( 658)								percentWidth = ((Float)0.0);
            							}
HXLINE( 660)							if (::Std_obj::isOfType(layoutItem,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 661)								::Dynamic measureItem = layoutItem;
HXLINE( 662)								totalMinWidth = (totalMinWidth + ::feathers::core::IMeasureObject_obj::get_minWidth(measureItem));
            							}
HXLINE( 664)							totalPercentWidth = (totalPercentWidth + percentWidth);
HXLINE( 665)							if (::hx::IsNotNull( layoutData->get_marginLeft() )) {
HXLINE( 666)								totalMeasuredWidth = (totalMeasuredWidth + layoutData->get_marginLeft());
            							}
HXLINE( 668)							if (::hx::IsNotNull( layoutData->get_marginRight() )) {
HXLINE( 669)								totalMeasuredWidth = (totalMeasuredWidth + layoutData->get_marginRight());
            							}
HXLINE( 671)							totalMeasuredWidth = (totalMeasuredWidth + adjustedGap);
HXLINE( 672)							pendingItems->push(layoutItem);
HXLINE( 673)							continue;
            						}
            					}
            				}
HXLINE( 677)				totalMeasuredWidth = (totalMeasuredWidth + (item->get_width() + adjustedGap));
            			}
            		}
HXLINE( 679)		totalMeasuredWidth = (totalMeasuredWidth - adjustedGap);
HXLINE( 680)		totalMeasuredWidth = (totalMeasuredWidth + (this->_paddingLeft + this->_paddingRight));
HXLINE( 681)		if ((totalPercentWidth < ((Float)100.0))) {
HXLINE( 682)			totalPercentWidth = ((Float)100.0);
            		}
HXLINE( 684)		Float remainingWidth = ((Float)0.0);
HXLINE( 685)		if (::hx::IsNotNull( explicitWidth )) {
HXLINE( 686)			remainingWidth = ( (Float)(explicitWidth) );
            		}
            		else {
HXLINE( 688)			remainingWidth = (totalMeasuredWidth + totalMinWidth);
HXLINE( 689)			bool _hx_tmp;
HXDLIN( 689)			if (::hx::IsNotNull( explicitMinWidth )) {
HXLINE( 689)				_hx_tmp = ::hx::IsLess( remainingWidth,explicitMinWidth );
            			}
            			else {
HXLINE( 689)				_hx_tmp = false;
            			}
HXDLIN( 689)			if (_hx_tmp) {
HXLINE( 690)				remainingWidth = ( (Float)(explicitMinWidth) );
            			}
            			else {
HXLINE( 691)				bool _hx_tmp1;
HXDLIN( 691)				if (::hx::IsNotNull( explicitMaxWidth )) {
HXLINE( 691)					_hx_tmp1 = ::hx::IsGreater( remainingWidth,explicitMaxWidth );
            				}
            				else {
HXLINE( 691)					_hx_tmp1 = false;
            				}
HXDLIN( 691)				if (_hx_tmp1) {
HXLINE( 692)					remainingWidth = ( (Float)(explicitMaxWidth) );
            				}
            			}
            		}
HXLINE( 695)		remainingWidth = (remainingWidth - totalMeasuredWidth);
HXLINE( 696)		if ((remainingWidth < ((Float)0.0))) {
HXLINE( 697)			remainingWidth = ((Float)0.0);
            		}
HXLINE( 699)		bool needsAnotherPass = true;
HXLINE( 700)		while(needsAnotherPass){
HXLINE( 701)			needsAnotherPass = false;
HXLINE( 702)			Float percentToPixels = (remainingWidth / totalPercentWidth);
HXLINE( 703)			{
HXLINE( 703)				int _g1 = 0;
HXDLIN( 703)				while((_g1 < pendingItems->length)){
HXLINE( 703)					::Dynamic layoutItem1 = pendingItems->__get(_g1);
HXDLIN( 703)					_g1 = (_g1 + 1);
HXLINE( 704)					 ::feathers::layout::HorizontalLayoutData layoutData1 = ::hx::TCast<  ::feathers::layout::HorizontalLayoutData >::cast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutItem1));
HXLINE( 705)					 ::Dynamic percentWidth1 = layoutData1->get_percentWidth();
HXLINE( 706)					if (::hx::IsLess( percentWidth1,((Float)0.0) )) {
HXLINE( 707)						percentWidth1 = ((Float)0.0);
            					}
HXLINE( 709)					Float itemWidth = (percentToPixels * ( (Float)(percentWidth1) ));
HXLINE( 710)					if (::Std_obj::isOfType(layoutItem1,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 711)						::Dynamic measureItem1 = layoutItem1;
HXLINE( 712)						 ::Dynamic itemMinWidth = ::feathers::core::IMeasureObject_obj::get_explicitMinWidth(measureItem1);
HXLINE( 713)						bool _hx_tmp2;
HXDLIN( 713)						if (::hx::IsNotNull( itemMinWidth )) {
HXLINE( 713)							_hx_tmp2 = ::hx::IsGreater( itemMinWidth,remainingWidth );
            						}
            						else {
HXLINE( 713)							_hx_tmp2 = false;
            						}
HXDLIN( 713)						if (_hx_tmp2) {
HXLINE( 717)							itemMinWidth = remainingWidth;
            						}
HXLINE( 719)						if (::hx::IsLess( itemWidth,itemMinWidth )) {
HXLINE( 720)							itemWidth = ( (Float)(itemMinWidth) );
HXLINE( 721)							remainingWidth = (remainingWidth - itemWidth);
HXLINE( 722)							totalPercentWidth = (totalPercentWidth - ( (Float)(percentWidth1) ));
HXLINE( 723)							pendingItems->remove(layoutItem1);
HXLINE( 724)							needsAnotherPass = true;
            						}
            					}
HXLINE( 730)					::hx::TCast<  ::openfl::display::DisplayObject >::cast(layoutItem1)->set_width(itemWidth);
HXLINE( 731)					if (::Std_obj::isOfType(layoutItem1,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 735)						::feathers::core::IValidating_obj::validateNow(layoutItem1);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(HorizontalLayout_obj,applyPercentWidth,(void))

void HorizontalLayout_obj::applyPercentHeight(::Array< ::Dynamic> items,Float viewPortHeight){
            	HX_STACKFRAME(&_hx_pos_d038c4414a8a4fea_741_applyPercentHeight)
HXLINE( 742)		Float availableHeight = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXLINE( 743)		{
HXLINE( 743)			int _g = 0;
HXDLIN( 743)			while((_g < items->length)){
HXLINE( 743)				 ::openfl::display::DisplayObject item = items->__get(_g).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 743)				_g = (_g + 1);
HXLINE( 744)				if (!(::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::layout::ILayoutObject >()))) {
HXLINE( 745)					continue;
            				}
HXLINE( 747)				::Dynamic layoutItem =  ::hx::interface_check(item,0xf54ca718);
HXLINE( 748)				if (!(::feathers::layout::ILayoutObject_obj::get_includeInLayout(layoutItem))) {
HXLINE( 749)					continue;
            				}
HXLINE( 751)				 ::feathers::layout::HorizontalLayoutData layoutData = ( ( ::feathers::layout::HorizontalLayoutData)(::Std_obj::downcast(::feathers::layout::ILayoutObject_obj::get_layoutData(layoutItem),::hx::ClassOf< ::feathers::layout::HorizontalLayoutData >())) );
HXLINE( 752)				if (::hx::IsNull( layoutData )) {
HXLINE( 753)					continue;
            				}
HXLINE( 755)				 ::Dynamic percentHeight = layoutData->get_percentHeight();
HXLINE( 756)				if (::hx::IsNull( percentHeight )) {
HXLINE( 757)					continue;
            				}
HXLINE( 759)				if (::hx::IsLess( percentHeight,((Float)0.0) )) {
HXLINE( 760)					percentHeight = ((Float)0.0);
            				}
            				else {
HXLINE( 761)					if (::hx::IsGreater( percentHeight,((Float)100.0) )) {
HXLINE( 762)						percentHeight = ((Float)100.0);
            					}
            				}
HXLINE( 764)				Float itemHeight = ((availableHeight * ( (Float)(percentHeight) )) / ((Float)100.0));
HXLINE( 765)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 766)					::Dynamic measureItem =  ::hx::interface_check(item,0xcfc32883);
HXLINE( 767)					 ::Dynamic itemMinHeight = ::feathers::core::IMeasureObject_obj::get_explicitMinHeight(measureItem);
HXLINE( 768)					if (::hx::IsNotNull( itemMinHeight )) {
HXLINE( 771)						if (::hx::IsGreater( itemMinHeight,availableHeight )) {
HXLINE( 772)							itemMinHeight = availableHeight;
            						}
HXLINE( 774)						if (::hx::IsLess( itemHeight,itemMinHeight )) {
HXLINE( 775)							itemHeight = ( (Float)(itemMinHeight) );
            						}
            					}
HXLINE( 778)					 ::Dynamic itemMaxHeight = ::feathers::core::IMeasureObject_obj::get_explicitMaxHeight(measureItem);
HXLINE( 779)					bool _hx_tmp;
HXDLIN( 779)					if (::hx::IsNotNull( itemMaxHeight )) {
HXLINE( 779)						_hx_tmp = ::hx::IsGreater( itemHeight,itemMaxHeight );
            					}
            					else {
HXLINE( 779)						_hx_tmp = false;
            					}
HXDLIN( 779)					if (_hx_tmp) {
HXLINE( 780)						itemHeight = ( (Float)(itemMaxHeight) );
            					}
            				}
HXLINE( 783)				item->set_height(itemHeight);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(HorizontalLayout_obj,applyPercentHeight,(void))


::hx::ObjectPtr< HorizontalLayout_obj > HorizontalLayout_obj::__new() {
	::hx::ObjectPtr< HorizontalLayout_obj > __this = new HorizontalLayout_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< HorizontalLayout_obj > HorizontalLayout_obj::__alloc(::hx::Ctx *_hx_ctx) {
	HorizontalLayout_obj *__this = (HorizontalLayout_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(HorizontalLayout_obj), true, "feathers.layout.HorizontalLayout"));
	*(void **)__this = HorizontalLayout_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

HorizontalLayout_obj::HorizontalLayout_obj()
{
}

void HorizontalLayout_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(HorizontalLayout);
	HX_MARK_MEMBER_NAME(_paddingTop,"_paddingTop");
	HX_MARK_MEMBER_NAME(_paddingRight,"_paddingRight");
	HX_MARK_MEMBER_NAME(_paddingBottom,"_paddingBottom");
	HX_MARK_MEMBER_NAME(_paddingLeft,"_paddingLeft");
	HX_MARK_MEMBER_NAME(_gap,"_gap");
	HX_MARK_MEMBER_NAME(_minGap,"_minGap");
	HX_MARK_MEMBER_NAME(_horizontalAlign,"_horizontalAlign");
	HX_MARK_MEMBER_NAME(_verticalAlign,"_verticalAlign");
	HX_MARK_MEMBER_NAME(_justifyResetEnabled,"_justifyResetEnabled");
	HX_MARK_MEMBER_NAME(_percentWidthResetEnabled,"_percentWidthResetEnabled");
	HX_MARK_MEMBER_NAME(_percentHeightResetEnabled,"_percentHeightResetEnabled");
	 ::openfl::events::EventDispatcher_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void HorizontalLayout_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_paddingTop,"_paddingTop");
	HX_VISIT_MEMBER_NAME(_paddingRight,"_paddingRight");
	HX_VISIT_MEMBER_NAME(_paddingBottom,"_paddingBottom");
	HX_VISIT_MEMBER_NAME(_paddingLeft,"_paddingLeft");
	HX_VISIT_MEMBER_NAME(_gap,"_gap");
	HX_VISIT_MEMBER_NAME(_minGap,"_minGap");
	HX_VISIT_MEMBER_NAME(_horizontalAlign,"_horizontalAlign");
	HX_VISIT_MEMBER_NAME(_verticalAlign,"_verticalAlign");
	HX_VISIT_MEMBER_NAME(_justifyResetEnabled,"_justifyResetEnabled");
	HX_VISIT_MEMBER_NAME(_percentWidthResetEnabled,"_percentWidthResetEnabled");
	HX_VISIT_MEMBER_NAME(_percentHeightResetEnabled,"_percentHeightResetEnabled");
	 ::openfl::events::EventDispatcher_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val HorizontalLayout_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"gap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_gap() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_gap") ) { return ::hx::Val( _gap ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"minGap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_minGap() ); }
		if (HX_FIELD_EQ(inName,"layout") ) { return ::hx::Val( layout_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"get_gap") ) { return ::hx::Val( get_gap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_gap") ) { return ::hx::Val( set_gap_dyn() ); }
		if (HX_FIELD_EQ(inName,"_minGap") ) { return ::hx::Val( _minGap ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"paddingTop") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingTop() ); }
		if (HX_FIELD_EQ(inName,"get_minGap") ) { return ::hx::Val( get_minGap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_minGap") ) { return ::hx::Val( set_minGap_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPadding") ) { return ::hx::Val( setPadding_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_paddingTop") ) { return ::hx::Val( _paddingTop ); }
		if (HX_FIELD_EQ(inName,"paddingLeft") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingLeft() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paddingRight") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingRight() ); }
		if (HX_FIELD_EQ(inName,"_paddingLeft") ) { return ::hx::Val( _paddingLeft ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_paddingRight") ) { return ::hx::Val( _paddingRight ); }
		if (HX_FIELD_EQ(inName,"paddingBottom") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingBottom() ); }
		if (HX_FIELD_EQ(inName,"verticalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_verticalAlign() ); }
		if (HX_FIELD_EQ(inName,"validateItems") ) { return ::hx::Val( validateItems_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_paddingTop") ) { return ::hx::Val( get_paddingTop_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingTop") ) { return ::hx::Val( set_paddingTop_dyn() ); }
		if (HX_FIELD_EQ(inName,"_paddingBottom") ) { return ::hx::Val( _paddingBottom ); }
		if (HX_FIELD_EQ(inName,"_verticalAlign") ) { return ::hx::Val( _verticalAlign ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_paddingLeft") ) { return ::hx::Val( get_paddingLeft_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingLeft") ) { return ::hx::Val( set_paddingLeft_dyn() ); }
		if (HX_FIELD_EQ(inName,"horizontalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_horizontalAlign() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_paddingRight") ) { return ::hx::Val( get_paddingRight_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingRight") ) { return ::hx::Val( set_paddingRight_dyn() ); }
		if (HX_FIELD_EQ(inName,"_horizontalAlign") ) { return ::hx::Val( _horizontalAlign ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_paddingBottom") ) { return ::hx::Val( get_paddingBottom_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingBottom") ) { return ::hx::Val( set_paddingBottom_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_verticalAlign") ) { return ::hx::Val( get_verticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_verticalAlign") ) { return ::hx::Val( set_verticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyPercentWidth") ) { return ::hx::Val( applyPercentWidth_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"applyVerticalAlign") ) { return ::hx::Val( applyVerticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyPercentHeight") ) { return ::hx::Val( applyPercentHeight_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"get_horizontalAlign") ) { return ::hx::Val( get_horizontalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_horizontalAlign") ) { return ::hx::Val( set_horizontalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"justifyResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_justifyResetEnabled() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_justifyResetEnabled") ) { return ::hx::Val( _justifyResetEnabled ); }
		if (HX_FIELD_EQ(inName,"applyHorizontalAlign") ) { return ::hx::Val( applyHorizontalAlign_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"get_justifyResetEnabled") ) { return ::hx::Val( get_justifyResetEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_justifyResetEnabled") ) { return ::hx::Val( set_justifyResetEnabled_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"percentWidthResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_percentWidthResetEnabled() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"_percentWidthResetEnabled") ) { return ::hx::Val( _percentWidthResetEnabled ); }
		if (HX_FIELD_EQ(inName,"percentHeightResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_percentHeightResetEnabled() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"_percentHeightResetEnabled") ) { return ::hx::Val( _percentHeightResetEnabled ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"get_percentWidthResetEnabled") ) { return ::hx::Val( get_percentWidthResetEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_percentWidthResetEnabled") ) { return ::hx::Val( set_percentWidthResetEnabled_dyn() ); }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"get_percentHeightResetEnabled") ) { return ::hx::Val( get_percentHeightResetEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_percentHeightResetEnabled") ) { return ::hx::Val( set_percentHeightResetEnabled_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val HorizontalLayout_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"gap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_gap(inValue.Cast< Float >()) ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_gap") ) { _gap=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"minGap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_minGap(inValue.Cast< Float >()) ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_minGap") ) { _minGap=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"paddingTop") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingTop(inValue.Cast< Float >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_paddingTop") ) { _paddingTop=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paddingLeft") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingLeft(inValue.Cast< Float >()) ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paddingRight") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingRight(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"_paddingLeft") ) { _paddingLeft=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_paddingRight") ) { _paddingRight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paddingBottom") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingBottom(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"verticalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_verticalAlign(inValue.Cast<  ::feathers::layout::VerticalAlign >()) ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_paddingBottom") ) { _paddingBottom=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_verticalAlign") ) { _verticalAlign=inValue.Cast<  ::feathers::layout::VerticalAlign >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"horizontalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_horizontalAlign(inValue.Cast<  ::feathers::layout::HorizontalAlign >()) ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_horizontalAlign") ) { _horizontalAlign=inValue.Cast<  ::feathers::layout::HorizontalAlign >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"justifyResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_justifyResetEnabled(inValue.Cast< bool >()) ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_justifyResetEnabled") ) { _justifyResetEnabled=inValue.Cast< bool >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"percentWidthResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_percentWidthResetEnabled(inValue.Cast< bool >()) ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"_percentWidthResetEnabled") ) { _percentWidthResetEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"percentHeightResetEnabled") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_percentHeightResetEnabled(inValue.Cast< bool >()) ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"_percentHeightResetEnabled") ) { _percentHeightResetEnabled=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void HorizontalLayout_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_paddingTop",63,ca,8f,0c));
	outFields->push(HX_("paddingTop",44,fd,05,3a));
	outFields->push(HX_("_paddingRight",2a,7f,16,fd));
	outFields->push(HX_("paddingRight",4b,ec,a7,1a));
	outFields->push(HX_("_paddingBottom",dd,57,eb,8d));
	outFields->push(HX_("paddingBottom",9c,67,99,4f));
	outFields->push(HX_("_paddingLeft",79,f8,ef,eb));
	outFields->push(HX_("paddingLeft",78,4a,e6,85));
	outFields->push(HX_("_gap",17,c2,19,3f));
	outFields->push(HX_("gap",16,7d,4e,00));
	outFields->push(HX_("_minGap",43,fc,5b,c1));
	outFields->push(HX_("minGap",a4,ea,e4,52));
	outFields->push(HX_("_horizontalAlign",c2,d1,46,df));
	outFields->push(HX_("horizontalAlign",41,8f,67,f4));
	outFields->push(HX_("_verticalAlign",b0,0e,ce,22));
	outFields->push(HX_("verticalAlign",6f,1e,7c,e4));
	outFields->push(HX_("_justifyResetEnabled",e3,44,2a,f0));
	outFields->push(HX_("justifyResetEnabled",e2,2d,d1,f0));
	outFields->push(HX_("_percentWidthResetEnabled",72,ca,e1,79));
	outFields->push(HX_("percentWidthResetEnabled",13,e5,32,20));
	outFields->push(HX_("_percentHeightResetEnabled",df,0e,47,4d));
	outFields->push(HX_("percentHeightResetEnabled",1e,41,ed,2d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo HorizontalLayout_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_paddingTop),HX_("_paddingTop",63,ca,8f,0c)},
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_paddingRight),HX_("_paddingRight",2a,7f,16,fd)},
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_paddingBottom),HX_("_paddingBottom",dd,57,eb,8d)},
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_paddingLeft),HX_("_paddingLeft",79,f8,ef,eb)},
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_gap),HX_("_gap",17,c2,19,3f)},
	{::hx::fsFloat,(int)offsetof(HorizontalLayout_obj,_minGap),HX_("_minGap",43,fc,5b,c1)},
	{::hx::fsObject /*  ::feathers::layout::HorizontalAlign */ ,(int)offsetof(HorizontalLayout_obj,_horizontalAlign),HX_("_horizontalAlign",c2,d1,46,df)},
	{::hx::fsObject /*  ::feathers::layout::VerticalAlign */ ,(int)offsetof(HorizontalLayout_obj,_verticalAlign),HX_("_verticalAlign",b0,0e,ce,22)},
	{::hx::fsBool,(int)offsetof(HorizontalLayout_obj,_justifyResetEnabled),HX_("_justifyResetEnabled",e3,44,2a,f0)},
	{::hx::fsBool,(int)offsetof(HorizontalLayout_obj,_percentWidthResetEnabled),HX_("_percentWidthResetEnabled",72,ca,e1,79)},
	{::hx::fsBool,(int)offsetof(HorizontalLayout_obj,_percentHeightResetEnabled),HX_("_percentHeightResetEnabled",df,0e,47,4d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *HorizontalLayout_obj_sStaticStorageInfo = 0;
#endif

static ::String HorizontalLayout_obj_sMemberFields[] = {
	HX_("_paddingTop",63,ca,8f,0c),
	HX_("get_paddingTop",8d,85,fb,af),
	HX_("set_paddingTop",01,6e,1b,d0),
	HX_("_paddingRight",2a,7f,16,fd),
	HX_("get_paddingRight",d4,d8,46,1f),
	HX_("set_paddingRight",48,c6,88,75),
	HX_("_paddingBottom",dd,57,eb,8d),
	HX_("get_paddingBottom",f3,72,09,56),
	HX_("set_paddingBottom",ff,4a,77,79),
	HX_("_paddingLeft",79,f8,ef,eb),
	HX_("get_paddingLeft",0f,02,c8,46),
	HX_("set_paddingLeft",1b,7f,93,42),
	HX_("_gap",17,c2,19,3f),
	HX_("get_gap",ad,45,c3,26),
	HX_("set_gap",b9,d6,c4,19),
	HX_("_minGap",43,fc,5b,c1),
	HX_("get_minGap",6d,5a,6c,43),
	HX_("set_minGap",e1,f8,e9,46),
	HX_("_horizontalAlign",c2,d1,46,df),
	HX_("get_horizontalAlign",58,5e,72,7f),
	HX_("set_horizontalAlign",64,51,0f,bc),
	HX_("_verticalAlign",b0,0e,ce,22),
	HX_("get_verticalAlign",c6,29,ec,ea),
	HX_("set_verticalAlign",d2,01,5a,0e),
	HX_("_justifyResetEnabled",e3,44,2a,f0),
	HX_("get_justifyResetEnabled",79,d4,26,f9),
	HX_("set_justifyResetEnabled",85,3d,88,fb),
	HX_("_percentWidthResetEnabled",72,ca,e1,79),
	HX_("get_percentWidthResetEnabled",1c,fb,86,61),
	HX_("set_percentWidthResetEnabled",90,46,b1,64),
	HX_("_percentHeightResetEnabled",df,0e,47,4d),
	HX_("get_percentHeightResetEnabled",f5,72,2c,16),
	HX_("set_percentHeightResetEnabled",01,2d,04,d8),
	HX_("setPadding",4f,7e,5c,23),
	HX_("layout",aa,ae,b8,58),
	HX_("validateItems",8a,6b,0c,ee),
	HX_("applyVerticalAlign",21,9c,1b,72),
	HX_("applyHorizontalAlign",73,5d,27,c7),
	HX_("applyPercentWidth",8f,8f,d2,d0),
	HX_("applyPercentHeight",3e,86,ba,9d),
	::String(null()) };

::hx::Class HorizontalLayout_obj::__mClass;

void HorizontalLayout_obj::__register()
{
	HorizontalLayout_obj _hx_dummy;
	HorizontalLayout_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("feathers.layout.HorizontalLayout",94,17,e8,c5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(HorizontalLayout_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< HorizontalLayout_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HorizontalLayout_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HorizontalLayout_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace feathers
} // end namespace layout
