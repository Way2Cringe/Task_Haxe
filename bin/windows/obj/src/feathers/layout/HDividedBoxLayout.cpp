// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_feathers_core_IDisplayObject
#include <feathers/core/IDisplayObject.h>
#endif
#ifndef INCLUDED_feathers_core_IMeasureObject
#include <feathers/core/IMeasureObject.h>
#endif
#ifndef INCLUDED_feathers_core_IValidating
#include <feathers/core/IValidating.h>
#endif
#ifndef INCLUDED_feathers_events_FeathersEvent
#include <feathers/events/FeathersEvent.h>
#endif
#ifndef INCLUDED_feathers_layout_HDividedBoxLayout
#include <feathers/layout/HDividedBoxLayout.h>
#endif
#ifndef INCLUDED_feathers_layout_ILayout
#include <feathers/layout/ILayout.h>
#endif
#ifndef INCLUDED_feathers_layout_LayoutBoundsResult
#include <feathers/layout/LayoutBoundsResult.h>
#endif
#ifndef INCLUDED_feathers_layout_Measurements
#include <feathers/layout/Measurements.h>
#endif
#ifndef INCLUDED_feathers_layout_VerticalAlign
#include <feathers/layout/VerticalAlign.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e519a24596d40538_30_new,"feathers.layout.HDividedBoxLayout","new",0x9770f69e,"feathers.layout.HDividedBoxLayout.new","feathers/layout/HDividedBoxLayout.hx",30,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_60_get_paddingTop,"feathers.layout.HDividedBoxLayout","get_paddingTop",0x3aa0ac0f,"feathers.layout.HDividedBoxLayout.get_paddingTop","feathers/layout/HDividedBoxLayout.hx",60,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_63_set_paddingTop,"feathers.layout.HDividedBoxLayout","set_paddingTop",0x5ac09483,"feathers.layout.HDividedBoxLayout.set_paddingTop","feathers/layout/HDividedBoxLayout.hx",63,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_92_get_paddingRight,"feathers.layout.HDividedBoxLayout","get_paddingRight",0x7a6423d6,"feathers.layout.HDividedBoxLayout.get_paddingRight","feathers/layout/HDividedBoxLayout.hx",92,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_95_set_paddingRight,"feathers.layout.HDividedBoxLayout","set_paddingRight",0xd0a6114a,"feathers.layout.HDividedBoxLayout.set_paddingRight","feathers/layout/HDividedBoxLayout.hx",95,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_124_get_paddingBottom,"feathers.layout.HDividedBoxLayout","get_paddingBottom",0xb48dc9b1,"feathers.layout.HDividedBoxLayout.get_paddingBottom","feathers/layout/HDividedBoxLayout.hx",124,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_127_set_paddingBottom,"feathers.layout.HDividedBoxLayout","set_paddingBottom",0xd7fba1bd,"feathers.layout.HDividedBoxLayout.set_paddingBottom","feathers/layout/HDividedBoxLayout.hx",127,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_156_get_paddingLeft,"feathers.layout.HDividedBoxLayout","get_paddingLeft",0x0ca48d4d,"feathers.layout.HDividedBoxLayout.get_paddingLeft","feathers/layout/HDividedBoxLayout.hx",156,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_159_set_paddingLeft,"feathers.layout.HDividedBoxLayout","set_paddingLeft",0x08700a59,"feathers.layout.HDividedBoxLayout.set_paddingLeft","feathers/layout/HDividedBoxLayout.hx",159,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_193_get_verticalAlign,"feathers.layout.HDividedBoxLayout","get_verticalAlign",0x49708084,"feathers.layout.HDividedBoxLayout.get_verticalAlign","feathers/layout/HDividedBoxLayout.hx",193,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_196_set_verticalAlign,"feathers.layout.HDividedBoxLayout","set_verticalAlign",0x6cde5890,"feathers.layout.HDividedBoxLayout.set_verticalAlign","feathers/layout/HDividedBoxLayout.hx",196,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_216_get_customItemWidths,"feathers.layout.HDividedBoxLayout","get_customItemWidths",0xbf7b253c,"feathers.layout.HDividedBoxLayout.get_customItemWidths","feathers/layout/HDividedBoxLayout.hx",216,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_219_set_customItemWidths,"feathers.layout.HDividedBoxLayout","set_customItemWidths",0x8c32dcb0,"feathers.layout.HDividedBoxLayout.set_customItemWidths","feathers/layout/HDividedBoxLayout.hx",219,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_239_get_fallbackFluidIndex,"feathers.layout.HDividedBoxLayout","get_fallbackFluidIndex",0xa9de3135,"feathers.layout.HDividedBoxLayout.get_fallbackFluidIndex","feathers/layout/HDividedBoxLayout.hx",239,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_242_set_fallbackFluidIndex,"feathers.layout.HDividedBoxLayout","set_fallbackFluidIndex",0xdd89ada9,"feathers.layout.HDividedBoxLayout.set_fallbackFluidIndex","feathers/layout/HDividedBoxLayout.hx",242,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_261_setPadding,"feathers.layout.HDividedBoxLayout","setPadding",0xb107bbd1,"feathers.layout.HDividedBoxLayout.setPadding","feathers/layout/HDividedBoxLayout.hx",261,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_271_layout,"feathers.layout.HDividedBoxLayout","layout",0x98d2832c,"feathers.layout.HDividedBoxLayout.layout","feathers/layout/HDividedBoxLayout.hx",271,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_335_validateItems,"feathers.layout.HDividedBoxLayout","validateItems",0xa5330b48,"feathers.layout.HDividedBoxLayout.validateItems","feathers/layout/HDividedBoxLayout.hx",335,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_353_applyVerticalAlign,"feathers.layout.HDividedBoxLayout","applyVerticalAlign",0xc7632ba3,"feathers.layout.HDividedBoxLayout.applyVerticalAlign","feathers/layout/HDividedBoxLayout.hx",353,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_376_applyPercentWidth,"feathers.layout.HDividedBoxLayout","applyPercentWidth",0x2f56e64d,"feathers.layout.HDividedBoxLayout.applyPercentWidth","feathers/layout/HDividedBoxLayout.hx",376,0xeaf588b2)
HX_LOCAL_STACK_FRAME(_hx_pos_e519a24596d40538_523_applyPercentHeight,"feathers.layout.HDividedBoxLayout","applyPercentHeight",0xf30215c0,"feathers.layout.HDividedBoxLayout.applyPercentHeight","feathers/layout/HDividedBoxLayout.hx",523,0xeaf588b2)
namespace feathers{
namespace layout{

void HDividedBoxLayout_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_30_new)
HXLINE( 228)		this->_fallbackFluidIndex = -1;
HXLINE( 168)		this->_verticalAlign = ::feathers::layout::VerticalAlign_obj::JUSTIFY_dyn();
HXLINE( 136)		this->_paddingLeft = ((Float)0.0);
HXLINE( 104)		this->_paddingBottom = ((Float)0.0);
HXLINE(  72)		this->_paddingRight = ((Float)0.0);
HXLINE(  40)		this->_paddingTop = ((Float)0.0);
HXLINE(  37)		super::__construct(null());
            	}

Dynamic HDividedBoxLayout_obj::__CreateEmpty() { return new HDividedBoxLayout_obj; }

void *HDividedBoxLayout_obj::_hx_vtable = 0;

Dynamic HDividedBoxLayout_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< HDividedBoxLayout_obj > _hx_result = new HDividedBoxLayout_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool HDividedBoxLayout_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0c89e854) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0c89e854;
	} else {
		return inClassId==(int)0x21ed69d0;
	}
}

static ::openfl::events::IEventDispatcher_obj _hx_feathers_layout_HDividedBoxLayout__hx_openfl_events_IEventDispatcher= {
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ,::hx::Null< int > ,::hx::Null< bool > ))&::feathers::layout::HDividedBoxLayout_obj::addEventListener,
	( bool (::hx::Object::*)( ::openfl::events::Event))&::feathers::layout::HDividedBoxLayout_obj::dispatchEvent,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HDividedBoxLayout_obj::hasEventListener,
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ))&::feathers::layout::HDividedBoxLayout_obj::removeEventListener,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HDividedBoxLayout_obj::willTrigger,
};

static ::feathers::layout::ILayout_obj _hx_feathers_layout_HDividedBoxLayout__hx_feathers_layout_ILayout= {
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ,::hx::Null< int > ,::hx::Null< bool > ))&::feathers::layout::HDividedBoxLayout_obj::addEventListener,
	( bool (::hx::Object::*)( ::openfl::events::Event))&::feathers::layout::HDividedBoxLayout_obj::dispatchEvent,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HDividedBoxLayout_obj::hasEventListener,
	( void (::hx::Object::*)(::String, ::Dynamic,::hx::Null< bool > ))&::feathers::layout::HDividedBoxLayout_obj::removeEventListener,
	( bool (::hx::Object::*)(::String))&::feathers::layout::HDividedBoxLayout_obj::willTrigger,
	(  ::feathers::layout::LayoutBoundsResult (::hx::Object::*)(::Array< ::Dynamic>, ::feathers::layout::Measurements, ::feathers::layout::LayoutBoundsResult))&::feathers::layout::HDividedBoxLayout_obj::layout,
};

void *HDividedBoxLayout_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x87530281: return &_hx_feathers_layout_HDividedBoxLayout__hx_openfl_events_IEventDispatcher;
		case (int)0x3e135379: return &_hx_feathers_layout_HDividedBoxLayout__hx_feathers_layout_ILayout;
	}
	return super::_hx_getInterface(inHash);
}

Float HDividedBoxLayout_obj::get_paddingTop(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_60_get_paddingTop)
HXDLIN(  60)		return this->_paddingTop;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_paddingTop,return )

Float HDividedBoxLayout_obj::set_paddingTop(Float value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_63_set_paddingTop)
HXLINE(  64)		if ((this->_paddingTop == value)) {
HXLINE(  65)			return this->_paddingTop;
            		}
HXLINE(  67)		this->_paddingTop = value;
HXLINE(  68)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE(  69)		return this->_paddingTop;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_paddingTop,return )

Float HDividedBoxLayout_obj::get_paddingRight(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_92_get_paddingRight)
HXDLIN(  92)		return this->_paddingRight;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_paddingRight,return )

Float HDividedBoxLayout_obj::set_paddingRight(Float value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_95_set_paddingRight)
HXLINE(  96)		if ((this->_paddingRight == value)) {
HXLINE(  97)			return this->_paddingRight;
            		}
HXLINE(  99)		this->_paddingRight = value;
HXLINE( 100)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 101)		return this->_paddingRight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_paddingRight,return )

Float HDividedBoxLayout_obj::get_paddingBottom(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_124_get_paddingBottom)
HXDLIN( 124)		return this->_paddingBottom;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_paddingBottom,return )

Float HDividedBoxLayout_obj::set_paddingBottom(Float value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_127_set_paddingBottom)
HXLINE( 128)		if ((this->_paddingBottom == value)) {
HXLINE( 129)			return this->_paddingBottom;
            		}
HXLINE( 131)		this->_paddingBottom = value;
HXLINE( 132)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 133)		return this->_paddingBottom;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_paddingBottom,return )

Float HDividedBoxLayout_obj::get_paddingLeft(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_156_get_paddingLeft)
HXDLIN( 156)		return this->_paddingLeft;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_paddingLeft,return )

Float HDividedBoxLayout_obj::set_paddingLeft(Float value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_159_set_paddingLeft)
HXLINE( 160)		if ((this->_paddingLeft == value)) {
HXLINE( 161)			return this->_paddingLeft;
            		}
HXLINE( 163)		this->_paddingLeft = value;
HXLINE( 164)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 165)		return this->_paddingLeft;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_paddingLeft,return )

 ::feathers::layout::VerticalAlign HDividedBoxLayout_obj::get_verticalAlign(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_193_get_verticalAlign)
HXDLIN( 193)		return this->_verticalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_verticalAlign,return )

 ::feathers::layout::VerticalAlign HDividedBoxLayout_obj::set_verticalAlign( ::feathers::layout::VerticalAlign value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_196_set_verticalAlign)
HXLINE( 197)		if (::hx::IsPointerEq( this->_verticalAlign,value )) {
HXLINE( 198)			return this->_verticalAlign;
            		}
HXLINE( 200)		this->_verticalAlign = value;
HXLINE( 201)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 202)		return this->_verticalAlign;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_verticalAlign,return )

::Array< ::Dynamic> HDividedBoxLayout_obj::get_customItemWidths(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_216_get_customItemWidths)
HXDLIN( 216)		return this->_customItemWidths;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_customItemWidths,return )

::Array< ::Dynamic> HDividedBoxLayout_obj::set_customItemWidths(::Array< ::Dynamic> value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_219_set_customItemWidths)
HXLINE( 220)		if (::hx::IsPointerEq( this->_customItemWidths,value )) {
HXLINE( 221)			return this->_customItemWidths;
            		}
HXLINE( 223)		this->_customItemWidths = value;
HXLINE( 224)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 225)		return this->_customItemWidths;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_customItemWidths,return )

int HDividedBoxLayout_obj::get_fallbackFluidIndex(){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_239_get_fallbackFluidIndex)
HXDLIN( 239)		return this->_fallbackFluidIndex;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HDividedBoxLayout_obj,get_fallbackFluidIndex,return )

int HDividedBoxLayout_obj::set_fallbackFluidIndex(int value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_242_set_fallbackFluidIndex)
HXLINE( 243)		if ((this->_fallbackFluidIndex == value)) {
HXLINE( 244)			return this->_fallbackFluidIndex;
            		}
HXLINE( 246)		this->_fallbackFluidIndex = value;
HXLINE( 247)		::feathers::events::FeathersEvent_obj::dispatch(::hx::ObjectPtr<OBJ_>(this),HX_("change",70,91,72,b7),null(),null());
HXLINE( 248)		return this->_fallbackFluidIndex;
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,set_fallbackFluidIndex,return )

void HDividedBoxLayout_obj::setPadding(Float value){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_261_setPadding)
HXLINE( 262)		this->set_paddingTop(value);
HXLINE( 263)		this->set_paddingRight(value);
HXLINE( 264)		this->set_paddingBottom(value);
HXLINE( 265)		this->set_paddingLeft(value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,setPadding,(void))

 ::feathers::layout::LayoutBoundsResult HDividedBoxLayout_obj::layout(::Array< ::Dynamic> items, ::feathers::layout::Measurements measurements, ::feathers::layout::LayoutBoundsResult result){
            	HX_GC_STACKFRAME(&_hx_pos_e519a24596d40538_271_layout)
HXLINE( 272)		{
HXLINE( 272)			int _g = 0;
HXDLIN( 272)			int _g1 = items->length;
HXDLIN( 272)			while((_g < _g1)){
HXLINE( 272)				_g = (_g + 1);
HXDLIN( 272)				int i = (_g - 1);
HXDLIN( 272)				 ::openfl::display::DisplayObject item = items->__get(i).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 272)				bool isDivider = (::hx::Mod(i,2) == 1);
HXDLIN( 272)				if (!(isDivider)) {
HXLINE( 272)					bool _hx_tmp;
HXDLIN( 272)					if (::hx::IsNotNull( this->_customItemWidths )) {
HXLINE( 272)						_hx_tmp = (i < this->_customItemWidths->length);
            					}
            					else {
HXLINE( 272)						_hx_tmp = false;
            					}
HXDLIN( 272)					if (_hx_tmp) {
HXLINE( 272)						 ::Dynamic itemWidth = this->_customItemWidths->__get(i);
HXDLIN( 272)						if (::hx::IsNotNull( itemWidth )) {
HXLINE( 272)							item->set_width(( (Float)(itemWidth) ));
            						}
            					}
            				}
HXDLIN( 272)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 272)					::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            				}
            			}
            		}
HXLINE( 273)		this->applyPercentWidth(items,measurements->width,measurements->minWidth,measurements->maxWidth);
HXLINE( 275)		Float contentWidth = this->_paddingLeft;
HXLINE( 276)		Float contentHeight = ((Float)0.0);
HXLINE( 277)		{
HXLINE( 277)			int _g2 = 0;
HXDLIN( 277)			while((_g2 < items->length)){
HXLINE( 277)				 ::openfl::display::DisplayObject item1 = items->__get(_g2).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 277)				_g2 = (_g2 + 1);
HXLINE( 278)				if (::Std_obj::isOfType(item1,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 280)					::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item1,0x64d4b3cd));
            				}
HXLINE( 282)				if ((contentHeight < item1->get_height())) {
HXLINE( 283)					contentHeight = item1->get_height();
            				}
HXLINE( 285)				item1->set_x(contentWidth);
HXLINE( 286)				contentWidth = (contentWidth + item1->get_width());
            			}
            		}
HXLINE( 288)		contentWidth = (contentWidth + this->_paddingRight);
HXLINE( 289)		contentHeight = (contentHeight + (this->_paddingTop + this->_paddingBottom));
HXLINE( 291)		Float viewPortWidth = contentWidth;
HXLINE( 292)		if (::hx::IsNotNull( measurements->width )) {
HXLINE( 293)			viewPortWidth = ( (Float)(measurements->width) );
            		}
            		else {
HXLINE( 295)			bool _hx_tmp1;
HXDLIN( 295)			if (::hx::IsNotNull( measurements->minWidth )) {
HXLINE( 295)				_hx_tmp1 = ::hx::IsLess( viewPortWidth,measurements->minWidth );
            			}
            			else {
HXLINE( 295)				_hx_tmp1 = false;
            			}
HXDLIN( 295)			if (_hx_tmp1) {
HXLINE( 296)				viewPortWidth = ( (Float)(measurements->minWidth) );
            			}
            			else {
HXLINE( 297)				bool _hx_tmp2;
HXDLIN( 297)				if (::hx::IsNotNull( measurements->maxWidth )) {
HXLINE( 297)					_hx_tmp2 = ::hx::IsGreater( viewPortWidth,measurements->maxWidth );
            				}
            				else {
HXLINE( 297)					_hx_tmp2 = false;
            				}
HXDLIN( 297)				if (_hx_tmp2) {
HXLINE( 298)					viewPortWidth = ( (Float)(measurements->maxWidth) );
            				}
            			}
            		}
HXLINE( 301)		Float viewPortHeight = contentHeight;
HXLINE( 302)		if (::hx::IsNotNull( measurements->height )) {
HXLINE( 303)			viewPortHeight = ( (Float)(measurements->height) );
            		}
            		else {
HXLINE( 305)			bool _hx_tmp3;
HXDLIN( 305)			if (::hx::IsNotNull( measurements->minHeight )) {
HXLINE( 305)				_hx_tmp3 = ::hx::IsLess( viewPortHeight,measurements->minHeight );
            			}
            			else {
HXLINE( 305)				_hx_tmp3 = false;
            			}
HXDLIN( 305)			if (_hx_tmp3) {
HXLINE( 306)				viewPortHeight = ( (Float)(measurements->minHeight) );
            			}
            			else {
HXLINE( 307)				bool _hx_tmp4;
HXDLIN( 307)				if (::hx::IsNotNull( measurements->maxHeight )) {
HXLINE( 307)					_hx_tmp4 = ::hx::IsGreater( viewPortHeight,measurements->maxHeight );
            				}
            				else {
HXLINE( 307)					_hx_tmp4 = false;
            				}
HXDLIN( 307)				if (_hx_tmp4) {
HXLINE( 308)					viewPortHeight = ( (Float)(measurements->maxHeight) );
            				}
            			}
            		}
HXLINE( 312)		this->applyPercentHeight(items,viewPortHeight);
HXLINE( 313)		{
HXLINE( 313)			int _g3 = 0;
HXDLIN( 313)			int _g4 = items->length;
HXDLIN( 313)			while((_g3 < _g4)){
HXLINE( 313)				_g3 = (_g3 + 1);
HXDLIN( 313)				int i1 = (_g3 - 1);
HXDLIN( 313)				bool isDivider1 = (::hx::Mod(i1,2) == 1);
HXDLIN( 313)				if (!(isDivider1)) {
HXLINE( 313)					continue;
            				}
HXDLIN( 313)				 ::openfl::display::DisplayObject item2 = items->__get(i1).StaticCast<  ::openfl::display::DisplayObject >();
HXDLIN( 313)				switch((int)(this->_verticalAlign->_hx_getIndex())){
            					case (int)0: {
HXLINE( 313)						item2->set_y(this->_paddingTop);
            					}
            					break;
            					case (int)1: {
HXLINE( 313)						Float _hx_tmp5 = this->_paddingTop;
HXDLIN( 313)						Float _hx_tmp6 = this->_paddingTop;
HXDLIN( 313)						Float _hx_tmp7 = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXDLIN( 313)						item2->set_y(::Math_obj::max(_hx_tmp5,(_hx_tmp6 + ((_hx_tmp7 - item2->get_height()) / ((Float)2.0)))));
            					}
            					break;
            					case (int)2: {
HXLINE( 313)						Float _hx_tmp8 = this->_paddingTop;
HXDLIN( 313)						Float _hx_tmp9 = (this->_paddingTop + ((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
HXDLIN( 313)						item2->set_y(::Math_obj::max(_hx_tmp8,(_hx_tmp9 - item2->get_height())));
            					}
            					break;
            					case (int)3: {
HXLINE( 313)						item2->set_y(this->_paddingTop);
HXDLIN( 313)						item2->set_height(((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
            					}
            					break;
            				}
            			}
            		}
HXLINE( 315)		if ((contentWidth < viewPortWidth)) {
HXLINE( 316)			contentWidth = viewPortWidth;
            		}
HXLINE( 318)		if ((contentHeight < viewPortHeight)) {
HXLINE( 319)			contentHeight = viewPortHeight;
            		}
HXLINE( 322)		if (::hx::IsNull( result )) {
HXLINE( 323)			result =  ::feathers::layout::LayoutBoundsResult_obj::__alloc( HX_CTX );
            		}
HXLINE( 325)		result->contentX = ((Float)0.0);
HXLINE( 326)		result->contentY = ((Float)0.0);
HXLINE( 327)		result->contentWidth = contentWidth;
HXLINE( 328)		result->contentHeight = contentHeight;
HXLINE( 329)		result->viewPortWidth = viewPortWidth;
HXLINE( 330)		result->viewPortHeight = viewPortHeight;
HXLINE( 331)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC3(HDividedBoxLayout_obj,layout,return )

void HDividedBoxLayout_obj::validateItems(::Array< ::Dynamic> items){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_335_validateItems)
HXDLIN( 335)		int _g = 0;
HXDLIN( 335)		int _g1 = items->length;
HXDLIN( 335)		while((_g < _g1)){
HXDLIN( 335)			_g = (_g + 1);
HXDLIN( 335)			int i = (_g - 1);
HXLINE( 336)			 ::openfl::display::DisplayObject item = items->__get(i).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 337)			bool isDivider = (::hx::Mod(i,2) == 1);
HXLINE( 338)			if (!(isDivider)) {
HXLINE( 339)				bool _hx_tmp;
HXDLIN( 339)				if (::hx::IsNotNull( this->_customItemWidths )) {
HXLINE( 339)					_hx_tmp = (i < this->_customItemWidths->length);
            				}
            				else {
HXLINE( 339)					_hx_tmp = false;
            				}
HXDLIN( 339)				if (_hx_tmp) {
HXLINE( 340)					 ::Dynamic itemWidth = this->_customItemWidths->__get(i);
HXLINE( 341)					if (::hx::IsNotNull( itemWidth )) {
HXLINE( 342)						item->set_width(( (Float)(itemWidth) ));
            					}
            				}
            			}
HXLINE( 346)			if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 347)				::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(HDividedBoxLayout_obj,validateItems,(void))

void HDividedBoxLayout_obj::applyVerticalAlign(::Array< ::Dynamic> items,Float viewPortHeight){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_353_applyVerticalAlign)
HXDLIN( 353)		int _g = 0;
HXDLIN( 353)		int _g1 = items->length;
HXDLIN( 353)		while((_g < _g1)){
HXDLIN( 353)			_g = (_g + 1);
HXDLIN( 353)			int i = (_g - 1);
HXLINE( 354)			bool isDivider = (::hx::Mod(i,2) == 1);
HXLINE( 355)			if (!(isDivider)) {
HXLINE( 356)				continue;
            			}
HXLINE( 358)			 ::openfl::display::DisplayObject item = items->__get(i).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 359)			switch((int)(this->_verticalAlign->_hx_getIndex())){
            				case (int)0: {
HXLINE( 365)					item->set_y(this->_paddingTop);
            				}
            				break;
            				case (int)1: {
HXLINE( 363)					Float _hx_tmp = this->_paddingTop;
HXDLIN( 363)					Float _hx_tmp1 = this->_paddingTop;
HXDLIN( 363)					Float _hx_tmp2 = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXDLIN( 363)					item->set_y(::Math_obj::max(_hx_tmp,(_hx_tmp1 + ((_hx_tmp2 - item->get_height()) / ((Float)2.0)))));
            				}
            				break;
            				case (int)2: {
HXLINE( 361)					Float _hx_tmp3 = this->_paddingTop;
HXDLIN( 361)					Float _hx_tmp4 = (this->_paddingTop + ((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
HXDLIN( 361)					item->set_y(::Math_obj::max(_hx_tmp3,(_hx_tmp4 - item->get_height())));
            				}
            				break;
            				case (int)3: {
HXLINE( 367)					item->set_y(this->_paddingTop);
HXLINE( 368)					item->set_height(((viewPortHeight - this->_paddingTop) - this->_paddingBottom));
            				}
            				break;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(HDividedBoxLayout_obj,applyVerticalAlign,(void))

void HDividedBoxLayout_obj::applyPercentWidth(::Array< ::Dynamic> items, ::Dynamic explicitWidth, ::Dynamic explicitMinWidth, ::Dynamic explicitMaxWidth){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_376_applyPercentWidth)
HXLINE( 377)		::Array< int > customWidthIndices = ::Array_obj< int >::__new(0);
HXLINE( 378)		::Array< int > pendingIndices = ::Array_obj< int >::__new(0);
HXLINE( 379)		Float totalMeasuredWidth = ((Float)0.0);
HXLINE( 380)		Float totalMinWidth = ((Float)0.0);
HXLINE( 381)		Float totalPercentWidth = ((Float)0.0);
HXLINE( 382)		{
HXLINE( 382)			int _g = 0;
HXDLIN( 382)			int _g1 = items->length;
HXDLIN( 382)			while((_g < _g1)){
HXLINE( 382)				_g = (_g + 1);
HXDLIN( 382)				int i = (_g - 1);
HXLINE( 383)				 ::openfl::display::DisplayObject item = items->__get(i).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 384)				bool isDivider = (::hx::Mod(i,2) == 1);
HXLINE( 385)				if (!(isDivider)) {
HXLINE( 386)					int nonDividerIndex = ::Math_obj::floor((( (Float)(i) ) / ( (Float)(2) )));
HXLINE( 387)					bool needsPercentWidth = true;
HXLINE( 388)					bool _hx_tmp;
HXDLIN( 388)					if (::hx::IsNotNull( this->_customItemWidths )) {
HXLINE( 388)						_hx_tmp = (nonDividerIndex < this->_customItemWidths->length);
            					}
            					else {
HXLINE( 388)						_hx_tmp = false;
            					}
HXDLIN( 388)					if (_hx_tmp) {
HXLINE( 389)						 ::Dynamic itemWidth = this->_customItemWidths->__get(nonDividerIndex);
HXLINE( 390)						if (::hx::IsNotNull( itemWidth )) {
HXLINE( 391)							needsPercentWidth = false;
HXLINE( 392)							item->set_width(( (Float)(itemWidth) ));
HXLINE( 393)							customWidthIndices->push(i);
HXLINE( 394)							if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 398)								::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item,0x64d4b3cd));
            							}
            						}
            					}
HXLINE( 402)					if (needsPercentWidth) {
HXLINE( 403)						Float percentWidth = ((Float)100.0);
HXLINE( 404)						if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 405)							::Dynamic measureItem =  ::hx::interface_check(item,0xcfc32883);
HXLINE( 406)							 ::Dynamic columnExplicitMinWidth = ::feathers::core::IMeasureObject_obj::get_explicitMinWidth(measureItem);
HXLINE( 407)							if (::hx::IsNotNull( columnExplicitMinWidth )) {
HXLINE( 408)								totalMinWidth = (totalMinWidth + columnExplicitMinWidth);
            							}
            						}
HXLINE( 411)						totalPercentWidth = (totalPercentWidth + percentWidth);
HXLINE( 412)						pendingIndices->push(i);
HXLINE( 413)						continue;
            					}
            				}
HXLINE( 416)				totalMeasuredWidth = (totalMeasuredWidth + item->get_width());
            			}
            		}
HXLINE( 419)		totalMeasuredWidth = (totalMeasuredWidth + (this->_paddingLeft + this->_paddingRight));
HXLINE( 420)		Float remainingWidth = ((Float)0.0);
HXLINE( 421)		if (::hx::IsNotNull( explicitWidth )) {
HXLINE( 422)			remainingWidth = ( (Float)(explicitWidth) );
            		}
            		else {
HXLINE( 424)			remainingWidth = (totalMeasuredWidth + totalMinWidth);
HXLINE( 425)			bool _hx_tmp1;
HXDLIN( 425)			if (::hx::IsNotNull( explicitMinWidth )) {
HXLINE( 425)				_hx_tmp1 = ::hx::IsLess( remainingWidth,explicitMinWidth );
            			}
            			else {
HXLINE( 425)				_hx_tmp1 = false;
            			}
HXDLIN( 425)			if (_hx_tmp1) {
HXLINE( 426)				remainingWidth = ( (Float)(explicitMinWidth) );
            			}
            			else {
HXLINE( 427)				bool _hx_tmp2;
HXDLIN( 427)				if (::hx::IsNotNull( explicitMaxWidth )) {
HXLINE( 427)					_hx_tmp2 = ::hx::IsGreater( remainingWidth,explicitMaxWidth );
            				}
            				else {
HXLINE( 427)					_hx_tmp2 = false;
            				}
HXDLIN( 427)				if (_hx_tmp2) {
HXLINE( 428)					remainingWidth = ( (Float)(explicitMaxWidth) );
            				}
            			}
            		}
HXLINE( 431)		remainingWidth = (remainingWidth - totalMeasuredWidth);
HXLINE( 432)		bool needsAnotherPass = false;
HXLINE( 433)		do {
HXLINE( 434)			needsAnotherPass = false;
HXLINE( 435)			Float widthSum = ((Float)0.0);
HXLINE( 436)			Float percentToPixels = (remainingWidth / totalPercentWidth);
HXLINE( 437)			if ((percentToPixels < ((Float)0.0))) {
HXLINE( 438)				percentToPixels = ((Float)0.0);
            			}
HXLINE( 440)			{
HXLINE( 440)				int _g2 = 0;
HXDLIN( 440)				while((_g2 < pendingIndices->length)){
HXLINE( 440)					int index = pendingIndices->__get(_g2);
HXDLIN( 440)					_g2 = (_g2 + 1);
HXLINE( 441)					 ::openfl::display::DisplayObject item1 = items->__get(index).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 442)					Float percentWidth1 = ((Float)100.0);
HXLINE( 445)					Float itemWidth1 = ::Math_obj::ffloor((percentToPixels * percentWidth1));
HXLINE( 446)					 ::Dynamic columnMinWidth = null();
HXLINE( 447)					if (::Std_obj::isOfType(item1,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 448)						::Dynamic measureItem1 =  ::hx::interface_check(item1,0xcfc32883);
HXLINE( 449)						columnMinWidth = ::feathers::core::IMeasureObject_obj::get_explicitMinWidth(measureItem1);
            					}
HXLINE( 452)					if (::hx::IsNotNull( columnMinWidth )) {
HXLINE( 453)						if (::hx::IsGreater( columnMinWidth,remainingWidth )) {
HXLINE( 457)							columnMinWidth = remainingWidth;
            						}
HXLINE( 459)						if (::hx::IsLess( itemWidth1,columnMinWidth )) {
HXLINE( 460)							itemWidth1 = ( (Float)(columnMinWidth) );
HXLINE( 461)							remainingWidth = (remainingWidth - itemWidth1);
HXLINE( 462)							totalPercentWidth = (totalPercentWidth - percentWidth1);
HXLINE( 463)							pendingIndices->remove(index);
HXLINE( 464)							needsAnotherPass = true;
            						}
            					}
HXLINE( 467)					item1->set_width(itemWidth1);
HXLINE( 468)					if (::Std_obj::isOfType(item1,::hx::ClassOf< ::feathers::core::IValidating >())) {
HXLINE( 472)						::feathers::core::IValidating_obj::validateNow( ::hx::interface_check(item1,0x64d4b3cd));
            					}
HXLINE( 474)					widthSum = (widthSum + itemWidth1);
            				}
            			}
HXLINE( 476)			if (needsAnotherPass) {
HXLINE( 477)				widthSum = ((Float)0.0);
            			}
            			else {
HXLINE( 479)				remainingWidth = (remainingWidth - widthSum);
            			}
            		} while(needsAnotherPass);
;
HXLINE( 482)		bool _hx_tmp3;
HXDLIN( 482)		if ((remainingWidth > ((Float)0.0))) {
HXLINE( 482)			_hx_tmp3 = (pendingIndices->length > 0);
            		}
            		else {
HXLINE( 482)			_hx_tmp3 = false;
            		}
HXDLIN( 482)		if (_hx_tmp3) {
HXLINE( 485)			int index1 = pendingIndices->__get((pendingIndices->length - 1));
HXLINE( 486)			 ::openfl::display::DisplayObject finalItem = items->__get(index1).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 487)			finalItem->set_width((finalItem->get_width() + remainingWidth));
HXLINE( 488)			return;
            		}
HXLINE( 491)		if ((remainingWidth == ((Float)0.0))) {
HXLINE( 492)			return;
            		}
HXLINE( 495)		int index2 = this->_fallbackFluidIndex;
HXLINE( 496)		if ((index2 == -1)) {
HXLINE( 497)			index2 = (items->length - 1);
            		}
HXLINE( 499)		if ((index2 != -1)) {
HXLINE( 500)			 ::openfl::display::DisplayObject fallbackItem = items->__get(index2).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 501)			Float itemWidth2 = (fallbackItem->get_width() + remainingWidth);
HXLINE( 502)			if ((itemWidth2 < ((Float)0.0))) {
HXLINE( 503)				remainingWidth = itemWidth2;
HXLINE( 504)				itemWidth2 = ((Float)0.0);
HXLINE( 505)				customWidthIndices->remove(index2);
            			}
            			else {
HXLINE( 507)				remainingWidth = ((Float)0.0);
            			}
HXLINE( 509)			fallbackItem->set_width(itemWidth2);
            		}
HXLINE( 512)		if ((remainingWidth == ((Float)0.0))) {
HXLINE( 513)			return;
            		}
HXLINE( 516)		Float offset = (remainingWidth / ( (Float)(customWidthIndices->length) ));
HXLINE( 517)		{
HXLINE( 517)			int _g3 = 0;
HXDLIN( 517)			while((_g3 < customWidthIndices->length)){
HXLINE( 517)				int index3 = customWidthIndices->__get(_g3);
HXDLIN( 517)				_g3 = (_g3 + 1);
HXLINE( 518)				 ::openfl::display::DisplayObject item2 = items->__get(index3).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 519)				item2->set_width((item2->get_width() + offset));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(HDividedBoxLayout_obj,applyPercentWidth,(void))

void HDividedBoxLayout_obj::applyPercentHeight(::Array< ::Dynamic> items,Float viewPortHeight){
            	HX_STACKFRAME(&_hx_pos_e519a24596d40538_523_applyPercentHeight)
HXLINE( 524)		Float availableHeight = ((viewPortHeight - this->_paddingTop) - this->_paddingBottom);
HXLINE( 525)		{
HXLINE( 525)			int _g = 0;
HXDLIN( 525)			int _g1 = items->length;
HXDLIN( 525)			while((_g < _g1)){
HXLINE( 525)				_g = (_g + 1);
HXDLIN( 525)				int i = (_g - 1);
HXLINE( 526)				bool isDivider = (::hx::Mod(i,2) == 1);
HXLINE( 527)				if (isDivider) {
HXLINE( 528)					continue;
            				}
HXLINE( 530)				 ::openfl::display::DisplayObject item = items->__get(i).StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 531)				Float itemHeight = availableHeight;
HXLINE( 532)				if (::Std_obj::isOfType(item,::hx::ClassOf< ::feathers::core::IMeasureObject >())) {
HXLINE( 533)					::Dynamic measureItem =  ::hx::interface_check(item,0xcfc32883);
HXLINE( 534)					 ::Dynamic itemMinHeight = ::feathers::core::IMeasureObject_obj::get_explicitMinHeight(measureItem);
HXLINE( 535)					if (::hx::IsNotNull( itemMinHeight )) {
HXLINE( 538)						if (::hx::IsGreater( itemMinHeight,availableHeight )) {
HXLINE( 539)							itemMinHeight = availableHeight;
            						}
HXLINE( 541)						if (::hx::IsLess( itemHeight,itemMinHeight )) {
HXLINE( 542)							itemHeight = ( (Float)(itemMinHeight) );
            						}
            					}
HXLINE( 545)					 ::Dynamic itemMaxHeight = ::feathers::core::IMeasureObject_obj::get_explicitMaxHeight(measureItem);
HXLINE( 546)					bool _hx_tmp;
HXDLIN( 546)					if (::hx::IsNotNull( itemMaxHeight )) {
HXLINE( 546)						_hx_tmp = ::hx::IsGreater( itemHeight,itemMaxHeight );
            					}
            					else {
HXLINE( 546)						_hx_tmp = false;
            					}
HXDLIN( 546)					if (_hx_tmp) {
HXLINE( 547)						itemHeight = ( (Float)(itemMaxHeight) );
            					}
            				}
HXLINE( 550)				item->set_height(itemHeight);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(HDividedBoxLayout_obj,applyPercentHeight,(void))


::hx::ObjectPtr< HDividedBoxLayout_obj > HDividedBoxLayout_obj::__new() {
	::hx::ObjectPtr< HDividedBoxLayout_obj > __this = new HDividedBoxLayout_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< HDividedBoxLayout_obj > HDividedBoxLayout_obj::__alloc(::hx::Ctx *_hx_ctx) {
	HDividedBoxLayout_obj *__this = (HDividedBoxLayout_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(HDividedBoxLayout_obj), true, "feathers.layout.HDividedBoxLayout"));
	*(void **)__this = HDividedBoxLayout_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

HDividedBoxLayout_obj::HDividedBoxLayout_obj()
{
}

void HDividedBoxLayout_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(HDividedBoxLayout);
	HX_MARK_MEMBER_NAME(_paddingTop,"_paddingTop");
	HX_MARK_MEMBER_NAME(_paddingRight,"_paddingRight");
	HX_MARK_MEMBER_NAME(_paddingBottom,"_paddingBottom");
	HX_MARK_MEMBER_NAME(_paddingLeft,"_paddingLeft");
	HX_MARK_MEMBER_NAME(_verticalAlign,"_verticalAlign");
	HX_MARK_MEMBER_NAME(_customItemWidths,"_customItemWidths");
	HX_MARK_MEMBER_NAME(_fallbackFluidIndex,"_fallbackFluidIndex");
	 ::openfl::events::EventDispatcher_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void HDividedBoxLayout_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_paddingTop,"_paddingTop");
	HX_VISIT_MEMBER_NAME(_paddingRight,"_paddingRight");
	HX_VISIT_MEMBER_NAME(_paddingBottom,"_paddingBottom");
	HX_VISIT_MEMBER_NAME(_paddingLeft,"_paddingLeft");
	HX_VISIT_MEMBER_NAME(_verticalAlign,"_verticalAlign");
	HX_VISIT_MEMBER_NAME(_customItemWidths,"_customItemWidths");
	HX_VISIT_MEMBER_NAME(_fallbackFluidIndex,"_fallbackFluidIndex");
	 ::openfl::events::EventDispatcher_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val HDividedBoxLayout_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"layout") ) { return ::hx::Val( layout_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"paddingTop") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingTop() ); }
		if (HX_FIELD_EQ(inName,"setPadding") ) { return ::hx::Val( setPadding_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_paddingTop") ) { return ::hx::Val( _paddingTop ); }
		if (HX_FIELD_EQ(inName,"paddingLeft") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingLeft() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paddingRight") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingRight() ); }
		if (HX_FIELD_EQ(inName,"_paddingLeft") ) { return ::hx::Val( _paddingLeft ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_paddingRight") ) { return ::hx::Val( _paddingRight ); }
		if (HX_FIELD_EQ(inName,"paddingBottom") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_paddingBottom() ); }
		if (HX_FIELD_EQ(inName,"verticalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_verticalAlign() ); }
		if (HX_FIELD_EQ(inName,"validateItems") ) { return ::hx::Val( validateItems_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_paddingTop") ) { return ::hx::Val( get_paddingTop_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingTop") ) { return ::hx::Val( set_paddingTop_dyn() ); }
		if (HX_FIELD_EQ(inName,"_paddingBottom") ) { return ::hx::Val( _paddingBottom ); }
		if (HX_FIELD_EQ(inName,"_verticalAlign") ) { return ::hx::Val( _verticalAlign ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_paddingLeft") ) { return ::hx::Val( get_paddingLeft_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingLeft") ) { return ::hx::Val( set_paddingLeft_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_paddingRight") ) { return ::hx::Val( get_paddingRight_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingRight") ) { return ::hx::Val( set_paddingRight_dyn() ); }
		if (HX_FIELD_EQ(inName,"customItemWidths") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_customItemWidths() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_paddingBottom") ) { return ::hx::Val( get_paddingBottom_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_paddingBottom") ) { return ::hx::Val( set_paddingBottom_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_verticalAlign") ) { return ::hx::Val( get_verticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_verticalAlign") ) { return ::hx::Val( set_verticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"_customItemWidths") ) { return ::hx::Val( _customItemWidths ); }
		if (HX_FIELD_EQ(inName,"applyPercentWidth") ) { return ::hx::Val( applyPercentWidth_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"fallbackFluidIndex") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_fallbackFluidIndex() ); }
		if (HX_FIELD_EQ(inName,"applyVerticalAlign") ) { return ::hx::Val( applyVerticalAlign_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyPercentHeight") ) { return ::hx::Val( applyPercentHeight_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_fallbackFluidIndex") ) { return ::hx::Val( _fallbackFluidIndex ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"get_customItemWidths") ) { return ::hx::Val( get_customItemWidths_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_customItemWidths") ) { return ::hx::Val( set_customItemWidths_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"get_fallbackFluidIndex") ) { return ::hx::Val( get_fallbackFluidIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fallbackFluidIndex") ) { return ::hx::Val( set_fallbackFluidIndex_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val HDividedBoxLayout_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"paddingTop") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingTop(inValue.Cast< Float >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_paddingTop") ) { _paddingTop=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paddingLeft") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingLeft(inValue.Cast< Float >()) ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paddingRight") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingRight(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"_paddingLeft") ) { _paddingLeft=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_paddingRight") ) { _paddingRight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paddingBottom") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_paddingBottom(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"verticalAlign") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_verticalAlign(inValue.Cast<  ::feathers::layout::VerticalAlign >()) ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_paddingBottom") ) { _paddingBottom=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_verticalAlign") ) { _verticalAlign=inValue.Cast<  ::feathers::layout::VerticalAlign >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"customItemWidths") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_customItemWidths(inValue.Cast< ::Array< ::Dynamic> >()) ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_customItemWidths") ) { _customItemWidths=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"fallbackFluidIndex") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_fallbackFluidIndex(inValue.Cast< int >()) ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_fallbackFluidIndex") ) { _fallbackFluidIndex=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void HDividedBoxLayout_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_paddingTop",63,ca,8f,0c));
	outFields->push(HX_("paddingTop",44,fd,05,3a));
	outFields->push(HX_("_paddingRight",2a,7f,16,fd));
	outFields->push(HX_("paddingRight",4b,ec,a7,1a));
	outFields->push(HX_("_paddingBottom",dd,57,eb,8d));
	outFields->push(HX_("paddingBottom",9c,67,99,4f));
	outFields->push(HX_("_paddingLeft",79,f8,ef,eb));
	outFields->push(HX_("paddingLeft",78,4a,e6,85));
	outFields->push(HX_("_verticalAlign",b0,0e,ce,22));
	outFields->push(HX_("verticalAlign",6f,1e,7c,e4));
	outFields->push(HX_("_customItemWidths",90,ba,9f,57));
	outFields->push(HX_("customItemWidths",31,cc,24,bf));
	outFields->push(HX_("_fallbackFluidIndex",89,c3,51,04));
	outFields->push(HX_("fallbackFluidIndex",6a,3f,77,24));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo HDividedBoxLayout_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(HDividedBoxLayout_obj,_paddingTop),HX_("_paddingTop",63,ca,8f,0c)},
	{::hx::fsFloat,(int)offsetof(HDividedBoxLayout_obj,_paddingRight),HX_("_paddingRight",2a,7f,16,fd)},
	{::hx::fsFloat,(int)offsetof(HDividedBoxLayout_obj,_paddingBottom),HX_("_paddingBottom",dd,57,eb,8d)},
	{::hx::fsFloat,(int)offsetof(HDividedBoxLayout_obj,_paddingLeft),HX_("_paddingLeft",79,f8,ef,eb)},
	{::hx::fsObject /*  ::feathers::layout::VerticalAlign */ ,(int)offsetof(HDividedBoxLayout_obj,_verticalAlign),HX_("_verticalAlign",b0,0e,ce,22)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(HDividedBoxLayout_obj,_customItemWidths),HX_("_customItemWidths",90,ba,9f,57)},
	{::hx::fsInt,(int)offsetof(HDividedBoxLayout_obj,_fallbackFluidIndex),HX_("_fallbackFluidIndex",89,c3,51,04)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *HDividedBoxLayout_obj_sStaticStorageInfo = 0;
#endif

static ::String HDividedBoxLayout_obj_sMemberFields[] = {
	HX_("_paddingTop",63,ca,8f,0c),
	HX_("get_paddingTop",8d,85,fb,af),
	HX_("set_paddingTop",01,6e,1b,d0),
	HX_("_paddingRight",2a,7f,16,fd),
	HX_("get_paddingRight",d4,d8,46,1f),
	HX_("set_paddingRight",48,c6,88,75),
	HX_("_paddingBottom",dd,57,eb,8d),
	HX_("get_paddingBottom",f3,72,09,56),
	HX_("set_paddingBottom",ff,4a,77,79),
	HX_("_paddingLeft",79,f8,ef,eb),
	HX_("get_paddingLeft",0f,02,c8,46),
	HX_("set_paddingLeft",1b,7f,93,42),
	HX_("_verticalAlign",b0,0e,ce,22),
	HX_("get_verticalAlign",c6,29,ec,ea),
	HX_("set_verticalAlign",d2,01,5a,0e),
	HX_("_customItemWidths",90,ba,9f,57),
	HX_("get_customItemWidths",3a,31,8f,dd),
	HX_("set_customItemWidths",ae,e8,46,aa),
	HX_("_fallbackFluidIndex",89,c3,51,04),
	HX_("get_fallbackFluidIndex",b3,b8,0b,7e),
	HX_("set_fallbackFluidIndex",27,35,b7,b1),
	HX_("setPadding",4f,7e,5c,23),
	HX_("layout",aa,ae,b8,58),
	HX_("validateItems",8a,6b,0c,ee),
	HX_("applyVerticalAlign",21,9c,1b,72),
	HX_("applyPercentWidth",8f,8f,d2,d0),
	HX_("applyPercentHeight",3e,86,ba,9d),
	::String(null()) };

::hx::Class HDividedBoxLayout_obj::__mClass;

void HDividedBoxLayout_obj::__register()
{
	HDividedBoxLayout_obj _hx_dummy;
	HDividedBoxLayout_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("feathers.layout.HDividedBoxLayout",ac,0f,16,aa);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(HDividedBoxLayout_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< HDividedBoxLayout_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HDividedBoxLayout_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HDividedBoxLayout_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace feathers
} // end namespace layout
